// Recipe tcr_leaf_generator, auto generated by UnrealTcc.

#include "TcrLeafGenerator.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrLeafGenerator::UTcrLeafGenerator() 
{
	MaxInputs = 2;
	tcc_blast_by_feature1 = UTccNode::CreateNodeWithDefine<UTccBlastByFeature>(this, TEXT("tcc_blast_by_feature1"));
	foreach_branch = UTccNode::CreateNodeWithDefine<UTccForBlock>(this, TEXT("foreach_branch"));
	foreach_branch->InitInputsCount(2);
		add_density = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("add_density"));
		use_resample = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("use_resample"));
			tcc_scatter3 = UTccNode::CreateNodeWithDefine<UTccScatter>(this, TEXT("tcc_scatter3"));
			delete_density = UTccNode::CreateNodeWithDefine<UTccAttribDelete>(this, TEXT("delete_density"));
			tcc_sort1 = UTccNode::CreateNodeWithDefine<UTccSort>(this, TEXT("tcc_sort1"));
			calc_real_points = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("calc_real_points"));
			tcc_resample1 = UTccNode::CreateNodeWithDefine<UTccResample>(this, TEXT("tcc_resample1"));
			tcc_blast_by_feature2 = UTccNode::CreateNodeWithDefine<UTccBlastByFeature>(this, TEXT("tcc_blast_by_feature2"));
			delete_density1 = UTccNode::CreateNodeWithDefine<UTccAttribDelete>(this, TEXT("delete_density1"));
		min_max_u = UTccNode::CreateNodeWithDefine<UTccAttribPromote>(this, TEXT("min_max_u"));
		enable_mirror = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("enable_mirror"));
			default_dir = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("default_dir"));
			mirror_dir_pos = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("mirror_dir_pos"));
			mirror_dir_neg = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("mirror_dir_neg"));
			tcc_merge1 = UTccNode::CreateNodeWithDefine<UTccMerge>(this, TEXT("tcc_merge1"));
		calc_rotation1 = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("calc_rotation1"));
		tcc_attrib_delete1 = UTccNode::CreateNodeWithDefine<UTccAttribDelete>(this, TEXT("tcc_attrib_delete1"));
		apply_scale = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("apply_scale"));
		tcc_instancer1 = UTccNode::CreateNodeWithDefine<UTccInstancer>(this, TEXT("tcc_instancer1"));
	ScaleRamp.ResizeRampPoints(3);
	ScaleRamp.AddRampPoint(0.0000f, 0.0000f);
	ScaleRamp.AddRampPoint(0.2510f, 1.0000f);
	ScaleRamp.AddRampPoint(1.0000f, 0.0000f);
	ScaleRampH.ResizeRampPoints(2);
	ScaleRampH.AddRampPoint(0.0000f, 0.0000f);
	ScaleRampH.AddRampPoint(1.0000f, 1.0000f);
}
void UTcrLeafGenerator::Execute(UTccNode* InNode) 
{
	{
		tcc_blast_by_feature1->SetInput(0, InNode->GetInput(0));
		FTccGeometryPtr Geo0 = tcc_blast_by_feature1->GetInput(0)->GetGeoResult(0);
		UTccBlastByFeature* Define1 = Cast<UTccBlastByFeature>(tcc_blast_by_feature1->GetDefine()); 
		Define1->ByAttrib = 1;
		Define1->Attrib = TEXT("level");
		Define1->Op = UTccBlastByFeature::NotEqual;
		Define1->Value = float(hs_detail(Geo0, "curr_level", 0));
		tcc_blast_by_feature1->Cook();
	}
	{
		foreach_branch->SetInput(0, tcc_blast_by_feature1);
		foreach_branch->SetInput(1, InNode->GetInput(0));
		UTccForBlock* Define1 = Cast<UTccForBlock>(foreach_branch->GetDefine()); 
		Define1->Itermethod = UTccForBlock::ByPiecesOrPoints;
		Define1->Method = UTccForBlock::MergeEachIteration;
		Define1->Class = UTccForBlock::Primitives;
		foreach_branch->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = Define1->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				UTccNode* block_input0 = NewObject<UTccNode>(GetTransientPackage());
				block_input0->SetGeoResult(0, Define1->GetGeometryPiece(piece));
				UTccNode* block_input1 = InNode->GetInput(0);
				{
					add_density->SetInput(0, block_input0);
					add_density->Cook();
					{
						FTccGeometryPtr Geo0 = add_density->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_density = Geo0->AddPointAttrib("density", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_branch_dir = Geo0->AddPointAttrib("branch_dir", FTccAttrib::EAttrType::F3);
						const FVector2f percent = Gpercent;
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _curveu = attr_curveu->GetData<float>()[i];
							float& _density = attr_density->GetData<float>()[i];
							FVector3f& _branch_dir = attr_branch_dir->GetData<FVector3f>()[i];
							// calc density
							float f = _curveu;
							_density = (f >= percent.X && f <= percent.Y)? 1.f : 0.f;
							// calc tangent dir
							FVector3f p0, p1;
							if(_ptnum == _numpt - 1)
							{
							    // last point
							  p0 = vex_pointp(Geo0, _ptnum - 1);
							  p1 = vex_pointp(Geo0, _ptnum);
							}
							else if(_ptnum == 0)
							{
							    // first point
							  p0 = vex_pointp(Geo0, _ptnum);
							  p1 = vex_pointp(Geo0, _ptnum + 1);
							}
							else
							{
							    // other points
							  p0 = vex_pointp(Geo0, _ptnum - 1);
							  p1 = vex_pointp(Geo0, _ptnum + 1);
							}
							FVector3f yaw_axis = vex_normalize(p1 - p0);
							_branch_dir = yaw_axis;
						}
					}
				}
				
				{
					use_resample->SetInput(0, add_density);
					UTccSwitch* Define2 = Cast<UTccSwitch>(use_resample->GetDefine()); 
					Define2->Input = int32(UseResample);
					Define2->NumCases = 2;
					use_resample->Cook();
					FTccGeometryPtr SwitchResult = nullptr;
					const int32 Selection = Define2->Input;
					switch (Selection)
					{
						case 0:
						{
							{
								tcc_scatter3->SetInput(0, add_density);
								UTccScatter* Define3 = Cast<UTccScatter>(tcc_scatter3->GetDefine()); 
								Define3->Usedensityattrib = 1;
								Define3->Npts = int32(Npts);
								Define3->ScatterSeed = int32(BranchSeed);
								Define3->Relaxpoints = 1;
								tcc_scatter3->Cook();
							}
							
							{
								delete_density->SetInput(0, tcc_scatter3);
								UTccAttribDelete* Define3 = Cast<UTccAttribDelete>(delete_density->GetDefine()); 
								Define3->Ptdel = TEXT("density");
								delete_density->Cook();
							}
							
							{
								tcc_sort1->SetInput(0, delete_density);
								UTccSort* Define3 = Cast<UTccSort>(tcc_sort1->GetDefine()); 
								Define3->Ptsort = UTccSort::ByAttribute;
								Define3->Pointattrib = TEXT("curveu");
								tcc_sort1->Cook();
							}
							
							
							
							
							
							SwitchResult = tcc_sort1->GetGeoResult(0);
						}
						break;
						case 1:
						{
							
							
							
							{
								calc_real_points->SetInput(0, add_density);
								calc_real_points->Cook();
								{
									FTccGeometryPtr Geo0 = calc_real_points->GetGeoResult(0);
									FTccAttribPtr attr_npts = Geo0->AddDetailAttrib("npts", FTccAttrib::EAttrType::I);
									int32& _npts = attr_npts->GetData<int32>()[0];
									int32 pts = Npts;
									FVector2f range = Gpercent;
									float percent = abs(range.Y - range.X);
									int32 real_pts = (int)ceil(pts / percent);
									_npts = real_pts;
								}
							}
							
							{
								tcc_resample1->SetInput(0, calc_real_points);
								FTccGeometryPtr Geo0 = tcc_resample1->GetInput(0)->GetGeoResult(0);
								UTccResample* Define3 = Cast<UTccResample>(tcc_resample1->GetDefine()); 
								Define3->Dolength = 0;
								Define3->Dosegs = 1;
								Define3->Segs = int32(hs_detail(Geo0, "npts", 0) - 1);
								tcc_resample1->Cook();
							}
							
							{
								tcc_blast_by_feature2->SetInput(0, tcc_resample1);
								UTccBlastByFeature* Define3 = Cast<UTccBlastByFeature>(tcc_blast_by_feature2->GetDefine()); 
								Define3->Grouptype = UTccBlastByFeature::Points;
								Define3->ByAttrib = 1;
								Define3->Attrib = TEXT("density");
								Define3->Op = UTccBlastByFeature::Less;
								Define3->Value = 0.500000f;
								tcc_blast_by_feature2->Cook();
							}
							
							{
								delete_density1->SetInput(0, tcc_blast_by_feature2);
								UTccAttribDelete* Define3 = Cast<UTccAttribDelete>(delete_density1->GetDefine()); 
								Define3->Ptdel = TEXT("density");
								Define3->Dtldel = TEXT("npts");
								delete_density1->Cook();
							}
							
							SwitchResult = delete_density1->GetGeoResult(0);
						}
						break;
						default:
						{
							checkNoEntry();
						}
						break;
					}
					use_resample->SetValidGeoResult(0, SwitchResult);
				}
				
				{
					min_max_u->SetInput(0, use_resample);
					UTccAttribPromote* Define2 = Cast<UTccAttribPromote>(min_max_u->GetDefine()); 
					Define2->Inname = TEXT("curveu");
					Define2->Outclass = UTccAttribPromote::DetailOnlyOnce;
					Define2->DoMax = 1;
					Define2->DoMin = 1;
					min_max_u->Cook();
				}
				
				{
					enable_mirror->SetInput(0, min_max_u);
					UTccSwitch* Define2 = Cast<UTccSwitch>(enable_mirror->GetDefine()); 
					Define2->Input = int32(Mirror);
					Define2->NumCases = 2;
					enable_mirror->Cook();
					FTccGeometryPtr SwitchResult = nullptr;
					const int32 Selection = Define2->Input;
					switch (Selection)
					{
						case 0:
						{
							{
								default_dir->SetInput(0, min_max_u);
								default_dir->Cook();
								{
									FTccGeometryPtr Geo0 = default_dir->GetGeoResult(0);
									FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", FTccAttrib::EAttrType::F);
									const int32 _numpt = Geo0->GetPointsCount();
									for(int32 i = 0; i < _numpt; i++)
									{
										const int32 _ptnum = i;
										float& _dir = attr_dir->GetData<float>()[i];
										_dir = 1.0f;
									}
								}
							}
							
							
							
							
							SwitchResult = default_dir->GetGeoResult(0);
						}
						break;
						case 1:
						{
							
							{
								mirror_dir_pos->SetInput(0, min_max_u);
								mirror_dir_pos->Cook();
								{
									FTccGeometryPtr Geo0 = mirror_dir_pos->GetGeoResult(0);
									FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", FTccAttrib::EAttrType::F);
									const int32 _numpt = Geo0->GetPointsCount();
									for(int32 i = 0; i < _numpt; i++)
									{
										const int32 _ptnum = i;
										float& _dir = attr_dir->GetData<float>()[i];
										_dir = 1.0f;
									}
								}
							}
							
							{
								mirror_dir_neg->SetInput(0, min_max_u);
								mirror_dir_neg->Cook();
								{
									FTccGeometryPtr Geo0 = mirror_dir_neg->GetGeoResult(0);
									FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", FTccAttrib::EAttrType::F);
									const int32 _numpt = Geo0->GetPointsCount();
									for(int32 i = 0; i < _numpt; i++)
									{
										const int32 _ptnum = i;
										float& _dir = attr_dir->GetData<float>()[i];
										_dir =  - 1.0f;
									}
								}
							}
							
							{
								tcc_merge1->SetInput(0, mirror_dir_pos);
								tcc_merge1->SetInput(1, mirror_dir_neg);
								tcc_merge1->Cook();
							}
							
							SwitchResult = tcc_merge1->GetGeoResult(0);
						}
						break;
						default:
						{
							checkNoEntry();
						}
						break;
					}
					enable_mirror->SetValidGeoResult(0, SwitchResult);
				}
				
				{
					calc_rotation1->SetInput(0, enable_mirror);
					calc_rotation1->SetInput(1, nullptr);
					calc_rotation1->Cook();
					{
						FTccGeometryPtr Geo0 = calc_rotation1->GetGeoResult(0);
						FTccAttribPtr attr_branch_dir = Geo0->AddPointAttrib("branch_dir", FTccAttrib::EAttrType::F3);
						FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", FTccAttrib::EAttrType::F4);
						const int32 gseed = BranchSeed;
						const int32 iter = _iteration;
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const FVector3f up = vex_set(0, 1, 0);
						const FVector2f yaw_range = vex_radians(YawRange);
						const float pitch = vex_radians(Pitch);
						const float pitch_rand = vex_radians(PitchRand);
						const float roll = vex_radians(Roll);
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _branch_dir = attr_branch_dir->GetData<FVector3f>()[i];
							float& _dir = attr_dir->GetData<float>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							FVector3f branch_dir = _branch_dir;
							// YAW
							FVector3f n = vex_normalize(vex_cross(branch_dir, up)) * _dir;
							FVector3f yaw_axis = vex_normalize(vex_cross(n, branch_dir));
							float yaw = vex_fit(_curveu, min_u, max_u, yaw_range.X, yaw_range.Y);
							FVector4f qyaw = vex_quaternion(yaw, yaw_axis);
							n = vex_qrotate(qyaw, n);
							// PITCH
							FVector3f pitch_axis = vex_cross(yaw_axis, n);
							float pitch_r = vex_fit01(vex_rand(_ptnum * 1.45f * iter + 21),  - pitch_rand, pitch_rand);
							float pitch_result = (pitch + pitch_r) * _dir;
							FVector4f qpitch = vex_quaternion(pitch_result, pitch_axis);
							n = vex_normalize(vex_qrotate(qpitch, n));
							// ROLL
							FVector4f qroll = vex_quaternion(roll, n);
							FVector3f new_up = vex_qrotate(qroll, up);
							// Convert to orient
							FMatrix44f m3 = vex_maketransform(n, new_up);
							_orient = vex_quaternion(m3);
						}
					}
				}
				
				{
					tcc_attrib_delete1->SetInput(0, calc_rotation1);
					UTccAttribDelete* Define2 = Cast<UTccAttribDelete>(tcc_attrib_delete1->GetDefine()); 
					Define2->Ptdel = TEXT("dir branch_dir");
					Define2->Dtldel = TEXT("max_curveu min_curveu");
					tcc_attrib_delete1->Cook();
				}
				
				{
					apply_scale->SetInput(0, tcc_attrib_delete1);
					apply_scale->SetInput(1, nullptr);
					apply_scale->Cook();
					{
						FTccGeometryPtr Geo0 = apply_scale->GetGeoResult(0);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						const int32 iter = _iteration;
						const FVector2f s = Scale;
						const int32 along_curve = EnableScaleCurve;
						const int32 along_height = EnableScaleHeight;
						const FVector2f height_range = HeightRange;
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _pscale = attr_pscale->GetData<float>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							_pscale = vex_fit01(vex_rand((_ptnum + 2.4f) * iter), s.X, s.Y);
							if(along_curve > 0)
							{
							  _pscale *= ScaleRamp.Lookup(_curveu);
							}
							if(along_height > 0)
							{
							  float h = (_P.Z - height_range.X) / (height_range.Y - height_range.X);
							  float s_sample = ScaleRampH.Lookup(h);
							  _pscale *= s_sample;
							}
						}
					}
				}
				
				{
					tcc_instancer1->SetInput(0, block_input1);
					tcc_instancer1->SetInput(1, apply_scale);
					tcc_instancer1->Cook();
				}
				
				Define1->SetPieceResult(piece, tcc_instancer1->GetGeoResult(0));
			}
			Define1->MergeResult(foreach_branch);
		}
	}
	InNode->SetGeoResult(output0, foreach_branch->GetGeoResult(0));
}

