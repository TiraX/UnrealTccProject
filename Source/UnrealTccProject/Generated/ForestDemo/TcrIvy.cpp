// Auto generated by UnrealTcc. 

#include "TcrIvy.h"
#include "TcrBroadLeaf.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrIvy::UTcrIvy() 
{
}
FTccNodePtr UTcrIvy::CreateNode() 
{
	TSharedPtr<FTcrIvy> Node = MakeShared<FTcrIvy>();
	SyncParams(Node);
	return Node;
}
void UTcrIvy::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrIvy> Node = StaticCastSharedPtr<FTcrIvy>(InNode);
	Node->Gseed = Gseed;
	Node->Steps = Steps;
	Node->StepsR = StepsR;
	Node->StepDis = StepDis;
	Node->StepDisR = StepDisR;
	Node->Away = Away;
	Node->Distort = Distort;
	Node->R = R;
	Node->Sep = Sep;
	Node->Yaw = Yaw;
	Node->YawR = YawR;
	Node->Pitch = Pitch;
	Node->PitchR = PitchR;
	Node->Scale = Scale;
	Node->ScaleR = ScaleR;
}

 FTcrIvy::FTcrIvy() 
{
	InitInputsCount(2);
	tcc_sdf_from_polygon1 = new FTccSdfFromPolygon();
	tcc_sdf_from_polygon1->InitMultiRefs(false); // RefCount = 1
	ivy_lines_vdb = new FTccVex();
	ivy_lines_vdb->InitMultiRefs(false); // RefCount = 1
	away_from_surface = new FTccVex();
	away_from_surface->InitMultiRefs(true); // RefCount = 2
	tcc_poly_wire1 = new FTccPolyWire();
	tcc_poly_wire1->InitMultiRefs(false); // RefCount = 1
	mi_trunk = new FTccUnrealMaterial();
	mi_trunk->InitMultiRefs(false); // RefCount = 1
	tcc_pack1 = new FTccPack();
	tcc_pack1->InitMultiRefs(false); // RefCount = 1
	tcr_broad_leaf1 = new FTcrBroadLeaf();
	tcr_broad_leaf1->InitMultiRefs(false); // RefCount = 1
	mi_leaf = new FTccUnrealMaterial();
	mi_leaf->InitMultiRefs(false); // RefCount = 1
	leaves_trans = new FTccVex();
	leaves_trans->InitMultiRefs(false); // RefCount = 1
	tcc_instancer1 = new FTccInstancer();
	tcc_instancer1->InitMultiRefs(false); // RefCount = 1
	tcc_merge1 = new FTccMerge();
	tcc_merge1->InitMultiRefs(false); // RefCount = 1
}
 FTcrIvy::~FTcrIvy() 
{
	delete tcc_sdf_from_polygon1; 
	delete ivy_lines_vdb; 
	delete away_from_surface; 
	delete tcc_poly_wire1; 
	delete mi_trunk; 
	delete tcc_pack1; 
	delete tcr_broad_leaf1; 
	delete mi_leaf; 
	delete leaves_trans; 
	delete tcc_instancer1; 
	delete tcc_merge1; 
}
void FTcrIvy::Cook() 
{
	{
		// Node: tcc_sdf_from_polygon1
		tcc_sdf_from_polygon1->SetInput(0, GetInput(0));
		tcc_sdf_from_polygon1->Voxelsize = float(StepDis + 0.05f);
		tcc_sdf_from_polygon1->Cook();
	}
	{
		// Node: ivy_lines_vdb
		ivy_lines_vdb->SetInput(0, nullptr);
		ivy_lines_vdb->SetInput(1, tcc_sdf_from_polygon1);
		ivy_lines_vdb->SetInput(2, GetInput(1));
		ivy_lines_vdb->Cook();
		{
			FTccGeometryPtr Geo0 = ivy_lines_vdb->GetGeoRef(0);
			FTccGeometryConstPtr Geo1 = tcc_sdf_from_polygon1->GetConstGeoResult(0);
			FTccGeometryConstPtr Geo2 = GetInput(1)->GetConstGeoResult(0);
			const int32 seed = Gseed + 4;
			const int32 num_ivy = vex_npoints(Geo2);
			const int32 num_steps = Steps;
			const float num_steps_r = StepsR;
			const float chaos = Distort;
			const float step_distance = StepDis;
			const float step_dis_r = StepDisR;
			const FVector2f radius = R;
			const FVector3f up = vex_set(0, 1, 0);
			for(int i = 0;i < num_ivy;i ++)
			{
			FVector3f pos = vex_pointp(Geo2, i);
			int32 local_seed = seed + i * 271;
			FVector3f n = vex_set(0, 0, 0);
			float local_step_dis = step_distance;
			if(step_dis_r > 0.f)
			local_step_dis *= 1.f - vex_rand(local_seed) * step_dis_r;
			int32 local_steps = num_steps;
			if(num_steps_r > 0.f)
			local_steps = (int)(num_steps * (1.f - vex_rand(local_seed + 9173) * num_steps_r));
			float inv_steps = 1.f / (local_steps - 1);
			float local_r = vex_fit01(vex_rand(local_seed + 8112), radius.X, radius.Y);
			FVector3f dir = up;
			TArray < FVector3f > poses;
			TArray < float > rads;
			TArray < FVector3f > normals;
			vex_resize(poses, local_steps);
			vex_resize(rads, local_steps);
			vex_resize(normals, local_steps);
			    //float dbg_dis[];
			    //resize(dbg_dis, local_steps);
			for(int s = 0;s < local_steps;++ s)
			{
			poses [ s] = pos;
			normals [ s] = n;
			        // radius
			float percent = inv_steps * s;
			percent = vex_fit(percent, 0.9f, 1.0f, 1.0f, 0.0f);
			rads [ s] = percent * local_r;
			        // random grow direction
			if(chaos > 0.f)
			{
			float h_r0 = vex_rand(local_seed + s) * 2.f - 1.f;
			float h_r1 = vex_rand(local_seed + s * 8 + 8) * 2.f - 1.f;
			FVector3f h_rand = vex_set(h_r0, 0.f, h_r1) * chaos;
			dir = vex_normalize(dir + h_rand);
			}
			FVector3f newp = pos + dir * local_step_dis;
			        // find sdf to surface
			float sdf = vex_volumesample(Geo1, 0, newp);
			        //dbg_dis[s] = sdf;
			n = vex_volumegradient(Geo1, 0, newp);
			n = vex_normalize(n);
			        // snap to surface
			pos = newp - n * sdf;
			dir = vex_normalize(pos - poses [ s]);
			dir = vex_normalize(dir + up * 0.5f);
			}
			    
			TArray < int32 > pts= vex_addpoints(Geo0, poses);
			vex_setpointsattrib(Geo0, "radius", pts, rads);
			vex_setpointsattrib(Geo0, "normal", pts, normals);
			    //setpointsattrib(0, "dis", pts, dbg_dis);
			vex_addprim(Geo0, "polyline", pts);
			}
		}
	}
	{
		// Node: away_from_surface
		away_from_surface->SetInput(0, ivy_lines_vdb);
		away_from_surface->Cook();
		{
			FTccGeometryPtr Geo0 = away_from_surface->GetGeoRef(0);
			FTccAttribPtr attr_normal = Geo0->AddPointAttrib("normal", ETccAttribType::F3);
			const float away = Away;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _P = Geo0->GetPositions()[i];
				FVector3f& _normal = attr_normal->GetData<FVector3f>()[i];
				_P += _normal * away;
			}
		}
	}
	{
		// Node: tcc_poly_wire1
		tcc_poly_wire1->SetInput(0, away_from_surface);
		tcc_poly_wire1->EnableRadiusAttrib = 1;
		tcc_poly_wire1->RAttrib = TEXT("radius");
		tcc_poly_wire1->Divs = 6;
		tcc_poly_wire1->Cook();
	}
	{
		// Node: mi_trunk
		mi_trunk->SetInput(0, tcc_poly_wire1);
		mi_trunk->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Trunk.MI_TreeBig_Trunk");
		mi_trunk->Cook();
	}
	{
		// Node: tcc_pack1
		tcc_pack1->SetInput(0, mi_trunk);
		tcc_pack1->GeoName = TEXT("ivy_stems");
		tcc_pack1->Cook();
	}
	{
		// Node: tcr_broad_leaf1
		tcr_broad_leaf1->RadRamp = ETccRampInterp::Linear;
		tcr_broad_leaf1->RadRamp.ResizeRampPoints(2);
		tcr_broad_leaf1->RadRamp.AddRampPoint(0.0000f, 1.0000f);
		tcr_broad_leaf1->RadRamp.AddRampPoint(1.0000f, 0.0000f);
		tcr_broad_leaf1->ShapeLeft = ETccRampInterp::Linear;
		tcr_broad_leaf1->ShapeLeft.ResizeRampPoints(7);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(0.0000f, 0.3000f);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(0.1016f, 0.6000f);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(0.2056f, 0.6667f);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(0.3253f, 0.8073f);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(0.5241f, 0.5938f);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(0.7827f, 0.3802f);
		tcr_broad_leaf1->ShapeLeft.AddRampPoint(1.0000f, 0.4844f);
		tcr_broad_leaf1->YawRemapLeft = ETccRampInterp::Linear;
		tcr_broad_leaf1->YawRemapLeft.ResizeRampPoints(2);
		tcr_broad_leaf1->YawRemapLeft.AddRampPoint(0.0000f, 0.0000f);
		tcr_broad_leaf1->YawRemapLeft.AddRampPoint(1.0000f, 1.0000f);
		tcr_broad_leaf1->ShapeRight = ETccRampInterp::Linear;
		tcr_broad_leaf1->ShapeRight.ResizeRampPoints(7);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(0.0000f, 0.3000f);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(0.1016f, 0.6000f);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(0.2003f, 0.6667f);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(0.3253f, 0.7500f);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(0.5256f, 0.5833f);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(0.6648f, 0.4844f);
		tcr_broad_leaf1->ShapeRight.AddRampPoint(1.0000f, 0.4844f);
		tcr_broad_leaf1->YawRemapRight = ETccRampInterp::Linear;
		tcr_broad_leaf1->YawRemapRight.ResizeRampPoints(2);
		tcr_broad_leaf1->YawRemapRight.AddRampPoint(0.0000f, 0.0000f);
		tcr_broad_leaf1->YawRemapRight.AddRampPoint(1.0000f, 1.0000f);
		tcr_broad_leaf1->USegs = 3;
		tcr_broad_leaf1->UAngle = 7.900000f;
		tcr_broad_leaf1->VSegs = 8;
		tcr_broad_leaf1->Stem = 0.000000f;
		tcr_broad_leaf1->UBend = 42.500000f;
		tcr_broad_leaf1->UBendOffset = 0.321000f;
		tcr_broad_leaf1->VBend = 18.299999f;
		tcr_broad_leaf1->YawBeginLeft = 27.400000f;
		tcr_broad_leaf1->YawBeginRight = 20.600000f;
		tcr_broad_leaf1->Cook();
	}
	{
		// Node: mi_leaf
		mi_leaf->SetInput(0, tcr_broad_leaf1);
		mi_leaf->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Leaf.MI_TreeBig_Leaf");
		mi_leaf->Cook();
	}
	{
		// Node: leaves_trans
		leaves_trans->SetInput(0, away_from_surface);
		leaves_trans->Cook();
		{
			FTccGeometryPtr Geo0 = leaves_trans->GetGeoRef(0);
			FTccAttribPtr attr_normal = Geo0->AddPointAttrib("normal", ETccAttribType::F3);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", ETccAttribType::F);
			FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
			FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", ETccAttribType::F);
			const int32 seed = Gseed;
			const int32 sep = Sep;
			const float yaw = vex_radians(Yaw);
			const float yaw_r = YawR;
			const float pitch = vex_radians(Pitch);
			const float pitch_r = PitchR;
			const float scale = Scale;
			const float scale_r = ScaleR;
			const FVector3f xaxis = vex_set(1, 0, 0);
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _P = Geo0->GetPositions()[i];
				FVector3f& _normal = attr_normal->GetData<FVector3f>()[i];
				float& _radius = attr_radius->GetData<float>()[i];
				FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
				float& _pscale = attr_pscale->GetData<float>()[i];
				FVector3f n = _normal;
				float ns = n.X + n.Y + n.Z;
				if(ns != 0.f &&((_ptnum + 1)% sep == 0))
				{
				FVector3f pos_last = vex_pointp(Geo0, _ptnum - 1);
				FVector3f forward = vex_normalize(pos_last - _P);
				_P += n * _radius;
				float sign = (_ptnum + 1) / sep % 2 == 0 ? 1.f : - 1.f;
				    
				FMatrix44f m = vex_maketransform(forward, n);
				FVector4f q = vex_quaternion(m);
				float r = 1.f;// vex_fit01(vex_rand(seed + _ptnum + 9281), 1.f - pitch_r, 1.f + pitch_r);
				float local_pitch = pitch * r;
				FVector4f qpitch = vex_quaternion( - local_pitch, xaxis);
				q = vex_qmultiply(q, qpitch);
				r = 1.f;// vex_fit01(vex_rand(seed + _ptnum + 4918), 1.f - yaw_r, 1.f + yaw_r);
				float local_yaw = yaw * r * sign;
				FVector4f qyaw = vex_quaternion(local_yaw, n);
				q = vex_qmultiply(qyaw, q);
				r = vex_fit01(vex_rand(seed + _ptnum + 3217), 1.f - scale_r, 1.f + scale_r);
				float local_scale = scale * r;
				_orient = q;
				_pscale = local_scale;
				}
			}
		}
	}
	{
		// Node: tcc_instancer1
		tcc_instancer1->SetInput(0, mi_leaf);
		tcc_instancer1->SetInput(1, leaves_trans);
		tcc_instancer1->Cook();
	}
	{
		// Node: tcc_merge1
		tcc_merge1->SetInput(0, tcc_pack1);
		tcc_merge1->SetInput(1, tcc_instancer1);
		tcc_merge1->Cook();
	}
	SetGeoResult(UTcrIvy::output0, tcc_merge1->GetGeoResult(0));
}

