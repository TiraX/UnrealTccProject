// Auto generated by UnrealTcc. 

#include "TcrTreeSimpleLeaf.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeSimpleLeaf::UTcrTreeSimpleLeaf() 
{
	Shape.ResizeRampPoints(7);
	Shape.AddRampPoint(0.0000f, 0.0885f);
	Shape.AddRampPoint(0.1035f, 0.7708f);
	Shape.AddRampPoint(0.3643f, 1.0000f);
	Shape.AddRampPoint(0.5442f, 1.0000f);
	Shape.AddRampPoint(0.7965f, 0.8125f);
	Shape.AddRampPoint(0.9337f, 0.1667f);
	Shape.AddRampPoint(1.0000f, 0.0000f);
}
FTccNodePtr UTcrTreeSimpleLeaf::CreateNode() 
{
	TSharedPtr<FTcrTreeSimpleLeaf> Node = MakeShared<FTcrTreeSimpleLeaf>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeSimpleLeaf::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeSimpleLeaf> Node = StaticCastSharedPtr<FTcrTreeSimpleLeaf>(InNode);
	Node->Shape = Shape;
	Node->Size = Size;
	Node->Rows = Rows;
	Node->Cols = Cols;
	Node->Stem = Stem;
	Node->EnableBend = EnableBend;
	Node->Bend = Bend;
	Node->BendOffset = BendOffset;
	Node->EnableCurl = EnableCurl;
	Node->Curl = Curl;
}

 FTcrTreeSimpleLeaf::FTcrTreeSimpleLeaf() 
{
	InitInputsCount(0);
	custom_grid = new FTccVex();
	custom_grid->InitMultiRefs(false); // RefCount = 1
	leaf_shape3 = new FTccVex();
	leaf_shape3->InitMultiRefs(false); // RefCount = 1
	enable_bend = new FTccSwitch();
	enable_bend->InitMultiRefs(false); // RefCount = 1
		bend_z = new FTccBend();
		bend_z->InitMultiRefs(false); // RefCount = 1
	enable_curl = new FTccSwitch();
	enable_curl->InitMultiRefs(false); // RefCount = 1
		bend_l = new FTccBend();
		bend_l->InitMultiRefs(false); // RefCount = 1
	uv_to_vertices = new FTccAttribPromote();
	uv_to_vertices->InitMultiRefs(false); // RefCount = 1
	rename_fmuv_to_uv = new FTccAttribRename();
	rename_fmuv_to_uv->InitMultiRefs(false); // RefCount = 1
	stem = new FTccSwitch();
	stem->InitMultiRefs(false); // RefCount = 1
		tcc_transform2 = new FTccTransform();
		tcc_transform2->InitMultiRefs(false); // RefCount = 1
		tcc_grid2 = new FTccGrid();
		tcc_grid2->InitMultiRefs(false); // RefCount = 1
		tcc_merge2 = new FTccMerge();
		tcc_merge2->InitMultiRefs(false); // RefCount = 1
	Shape.ResizeRampPoints(7);
	Shape.AddRampPoint(0.0000f, 0.0885f);
	Shape.AddRampPoint(0.1035f, 0.7708f);
	Shape.AddRampPoint(0.3643f, 1.0000f);
	Shape.AddRampPoint(0.5442f, 1.0000f);
	Shape.AddRampPoint(0.7965f, 0.8125f);
	Shape.AddRampPoint(0.9337f, 0.1667f);
	Shape.AddRampPoint(1.0000f, 0.0000f);
}
 FTcrTreeSimpleLeaf::~FTcrTreeSimpleLeaf() 
{
	delete custom_grid; 
	delete leaf_shape3; 
	delete enable_bend; 
		delete bend_z; 
	delete enable_curl; 
		delete bend_l; 
	delete uv_to_vertices; 
	delete rename_fmuv_to_uv; 
	delete stem; 
		delete tcc_transform2; 
		delete tcc_grid2; 
		delete tcc_merge2; 
}
void FTcrTreeSimpleLeaf::Cook() 
{
	{
		// Node: custom_grid
		FVector2f _size = FVector2f(Size.X, Size.Y);
		int32 _rows = int32(Rows);
		int32 _cols = int32(Cols);
		custom_grid->Cook();
		{
			FTccGeometryPtr Geo0 = custom_grid->GetGeoRef(0);
			const FVector2f s = _size;
			const int32 rows_ = _rows;
			const int32 cols_ = _cols;
			int32 total_pts = (rows_ - 2) * cols_ + 2 + 1;
			TArray < FVector3f > poses;
			vex_resize(poses, total_pts);
			float x_half = s.X * 0.5f;
			float x_step = s.X / (cols_ - 1);
			float z_step = s.Y / (rows_ - 1);
			// left 2 points
			poses [ 0] = vex_set( - x_half, 0.f, 0.f);
			poses [ 1] = vex_set(x_half, 0.f, 0.f);
			// middle ones
			int32 pt_index = 2;
			for(int z = 0;z < rows_ - 2;z ++)
			{
			float pos_z = z_step * (z + 1);
			for(int x = 0;x < cols_;x ++)
			{
			poses [ pt_index] = vex_set( - x_half + x_step * x, 0.f, pos_z);
			pt_index ++;
			}
			}
			// last 1 point
			poses [ pt_index] = vex_set(0.f, 0.f, z_step * (rows_ - 1));
			TArray < int32 > pts= vex_addpoints(Geo0, poses);
			int32 total_tris = (rows_ - 3) * (cols_ - 1) * 2 + cols_ + cols_ - 1;
			TArray < int32 > indices;
			vex_resize(indices, total_tris * 3);
			int32 id_index = 0;
			// prims in 1st row
			int32 mid_pt = cols_ / 2 + 2;
			indices [ 0] = 0;
			indices [ 1] = 1;
			indices [ 2] = mid_pt;
			id_index += 3;
			for(int x = 0;x < cols_ - 1;x ++)
			{
			if(x < mid_pt - 2)
			{
			indices [ id_index] = x + 2 + 1;
			indices [ id_index + 1] = x + 2;
			indices [ id_index + 2] = 0;
			}
			else
			{
			indices [ id_index] = x + 2 + 1;
			indices [ id_index + 1] = x + 2;
			indices [ id_index + 2] = 1;
			}
			id_index += 3;
			}
			// mid rows
			for(int z = 0;z < rows_ - 3;z ++)
			{
			for(int x = 0;x < cols_ - 1;x ++)
			{
			int32 z1 = z * cols_ + x + 2;
			int32 z2 = (z + 1) * cols_ + x + 2;
			        
			indices [ id_index] = z1;
			indices [ id_index + 1] = z1 + 1;
			indices [ id_index + 2] = z2 + 1;
			id_index += 3;
			        
			indices [ id_index] = z1;
			indices [ id_index + 1] = z2 + 1;
			indices [ id_index + 2] = z2;
			id_index += 3;
			}
			}
			// last row
			int32 last_pt = total_pts - 1;
			for(int x = 0;x < cols_ - 1;x ++)
			{
			int32 z1 = (rows_ - 3) * cols_ + x + 2;
			indices [ id_index] = z1;
			indices [ id_index + 1] = z1 + 1;
			indices [ id_index + 2] = last_pt;
			id_index += 3;
			}
			vex_addprims(Geo0, "poly", indices);
		}
	}
	{
		// Node: leaf_shape3
		leaf_shape3->SetInput(0, custom_grid);
		float _shrink = 0.900000f;
		leaf_shape3->Cook();
		{
			FTccGeometryPtr Geo0 = leaf_shape3->GetGeoRef(0);
			FTccAttribPtr attr_uv = Geo0->AddPointAttrib("uv", ETccAttribType::F2);
			const FVector2f s = Size;
			const float shrink = _shrink;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _P = Geo0->GetPositions()[i];
				FVector2f& _uv = attr_uv->GetData<FVector2f>()[i];
				FVector2f uv;
				uv.Y = _P.Y / s.Y;
				float w = Shape.Lookup(uv.Y);
				_P.X = _P.X * w;
				uv.X = _P.X / s.X + 0.5f;
				// shrink uv
				uv.Y = uv.Y * shrink + (1 - shrink) * 0.5f;
				uv.X = uv.X * shrink + (1 - shrink) * 0.5f;
				_uv = uv;
			}
		}
	}
	{
		// Node: enable_bend
		enable_bend->SetInput(0, leaf_shape3);
		enable_bend->Input = int32(EnableBend);
		enable_bend->NumCases = 2;
		enable_bend->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_bend->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: bend_z
					bend_z->SetInput(0, leaf_shape3);
					bend_z->Bend = float(Bend);
					bend_z->Origin = FVector3f(0.000000f, BendOffset, 0.000000f);
					bend_z->Length = float(Size.Y);
					bend_z->Cook();
				}
				
				SwitchResult = bend_z->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_bend->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: enable_curl
		enable_curl->SetInput(0, enable_bend);
		enable_curl->Input = int32(EnableCurl);
		enable_curl->NumCases = 2;
		enable_curl->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_curl->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: bend_l
					bend_l->SetInput(0, enable_bend);
					bend_l->Bend = float(Curl);
					bend_l->Dir = FVector3f(1.000000f, 0.000000f, 0.000000f);
					bend_l->Length = float(Size.X * 0.5f);
					bend_l->Symmetricdeformation = 1;
					bend_l->Cook();
				}
				
				SwitchResult = bend_l->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_curl->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: uv_to_vertices
		uv_to_vertices->SetInput(0, enable_curl);
		uv_to_vertices->Inname = TEXT("uv");
		uv_to_vertices->Outclass = UTccAttribPromote::Vertices;
		uv_to_vertices->Deletein = 1;
		uv_to_vertices->DoFirstMatch = 1;
		uv_to_vertices->Cook();
	}
	{
		// Node: rename_fmuv_to_uv
		rename_fmuv_to_uv->SetInput(0, uv_to_vertices);
		rename_fmuv_to_uv->Fromvtx0 = TEXT("fm_uv");
		rename_fmuv_to_uv->Tovtx0 = TEXT("uv");
		rename_fmuv_to_uv->Cook();
	}
	{
		// Node: stem
		stem->SetInput(0, rename_fmuv_to_uv);
		stem->Input = int32(Stem > 0);
		stem->NumCases = 2;
		stem->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = stem->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_transform2
					tcc_transform2->SetInput(0, rename_fmuv_to_uv);
					tcc_transform2->T = FVector3f(0.000000f, Stem, 0.000000f);
					tcc_transform2->Cook();
				}
				
				{
					// Node: tcc_grid2
					tcc_grid2->Size = FVector2f(Size.X * Shape.Lookup(0.0f, 0), Stem);
					tcc_grid2->T = FVector3f(0.000000f, tcc_grid2->Size.Y * 0.5f, 0.000000f);
					tcc_grid2->Rows = 2;
					tcc_grid2->Cols = 2;
					tcc_grid2->Uv = 1;
					tcc_grid2->Cook();
				}
				
				{
					// Node: tcc_merge2
					tcc_merge2->SetInput(0, tcc_transform2);
					tcc_merge2->SetInput(1, tcc_grid2);
					tcc_merge2->Cook();
				}
				
				SwitchResult = tcc_merge2->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		stem->SetValidGeoResult(0, SwitchResult);
	}
	SetGeoResult(UTcrTreeSimpleLeaf::output0, stem->GetGeoResult(0));
}

