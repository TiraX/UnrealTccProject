// Auto generated by UnrealTcc. 

#include "TcrTreeBranchFracLevel.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeBranchFracLevel::UTcrTreeBranchFracLevel() 
{
	ForceRamp.ResizeRampPoints(2);
	ForceRamp.AddRampPoint(0.0000f, 1.0000f);
	ForceRamp.AddRampPoint(1.0000f, 0.0000f);
	RadiusShape.ResizeRampPoints(2);
	RadiusShape.AddRampPoint(0.0000f, 1.0000f);
	RadiusShape.AddRampPoint(1.0000f, 0.7000f);
}
FTccNodePtr UTcrTreeBranchFracLevel::CreateNode() 
{
	TSharedPtr<FTcrTreeBranchFracLevel> Node = MakeShared<FTcrTreeBranchFracLevel>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeBranchFracLevel::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeBranchFracLevel> Node = StaticCastSharedPtr<FTcrTreeBranchFracLevel>(InNode);
	Node->ForceRamp = ForceRamp;
	Node->RadiusShape = RadiusShape;
	Node->Gseed = Gseed;
	Node->Sep = Sep;
	Node->SplitDis = SplitDis;
	Node->Angle = Angle;
	Node->Roll = Roll;
	Node->Force = Force;
}

 FTcrTreeBranchFracLevel::FTcrTreeBranchFracLevel() 
{
	InitInputsCount(1);
	foreach_begin2 = new FTccForBlock();
	foreach_begin2->InitMultiRefs(false); // RefCount = 1
	foreach_begin2->InitInputsCount(1);
		frac = new FTccVex();
		frac->InitMultiRefs(false); // RefCount = 1
	ForceRamp.ResizeRampPoints(2);
	ForceRamp.AddRampPoint(0.0000f, 1.0000f);
	ForceRamp.AddRampPoint(1.0000f, 0.0000f);
	RadiusShape.ResizeRampPoints(2);
	RadiusShape.AddRampPoint(0.0000f, 1.0000f);
	RadiusShape.AddRampPoint(1.0000f, 0.7000f);
}
 FTcrTreeBranchFracLevel::~FTcrTreeBranchFracLevel() 
{
	delete foreach_begin2; 
		delete frac; 
}
void FTcrTreeBranchFracLevel::Cook() 
{
	{
		// Node: foreach_begin2
		foreach_begin2->SetInput(0, GetInput(0));
		foreach_begin2->Itermethod = UTccForBlock::ByPiecesOrPoints;
		foreach_begin2->Method = UTccForBlock::MergeEachIteration;
		foreach_begin2->Class = UTccForBlock::Primitives;
		foreach_begin2->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = foreach_begin2->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				FTccNode* block_input0 = new FTccNode();
				block_input0->SetGeoResult(0, foreach_begin2->GetGeometryPiece(piece));
				{
					// Node: frac
					frac->SetInput(0, nullptr);
					frac->SetInput(1, block_input0);
					frac->Cook();
					{
						FTccGeometryPtr Geo0 = frac->GetGeoRef(0);
						FTccGeometryConstPtr Geo1 = block_input0->GetConstGeoResult(0);
						const FVector3f force_dir = vex_set(0, 1, 0);
						const float eps = 0.01f;
						TArray < int32 > parent_pts= vex_primpoints(Geo1, 0);
						int32 parent_end_pt = parent_pts [ vex_len(parent_pts) - 1];
						FVector3f origin = vex_pointp(Geo1, parent_end_pt);
						FVector3f parent_dir = vex_pointv(Geo1, "dir", parent_end_pt);
						float age_start = vex_pointf(Geo1, "age", parent_end_pt);
						float parent_radius = vex_pointf(Geo1, "radius", parent_end_pt);
						int32 parent_frac_level = vex_primi(Geo1, "frac_level", 0);
						int32 curr_frac_level = parent_frac_level + 1;
						float parent_oddeven = vex_primf(Geo1, "oddeven", 0);
						float sep = Sep;
						float split_dis = SplitDis;
						float split_dis_falloff = 1.f;
						float inv_split_dis = 1.f / split_dis;
						float angle = vex_radians(Angle);
						float roll = vex_radians(Roll);
						float force = Force;
						// int force_level;
						// calc frac directions
						FVector3f up = vex_set(0, 1, 0);
						if(vex_dot(up, parent_dir)> 0.99f)
						up = vex_set(1, 0, 0);
						FVector3f axis = vex_cross(up, parent_dir);
						axis = vex_cross(parent_dir, axis);
						float local_roll = roll * parent_frac_level * parent_oddeven;
						axis = vex_normalize(vex_qrotate(vex_quaternion(local_roll, parent_dir), axis));
						TArray < FVector3f > split_dir;
						TArray < float > oddeven;
						vex_resize(split_dir, 2);
						vex_resize(oddeven, 2);
						split_dir [ 0] = vex_normalize(vex_qrotate(vex_quaternion(angle, axis), parent_dir));
						split_dir [ 1] = vex_normalize(vex_qrotate(vex_quaternion( - angle, axis), parent_dir));
						oddeven [ 0] = 1.f;
						oddeven [ 1] =  - 1.f;
						// create 2 sub frac branches
						for(int i = 0;i < 2;i ++)
						{
						TArray < FVector3f > points;
						TArray < float > ages;
						TArray < float > rads;
						TArray < FVector3f > dirs;
						int32 total_segs = (int)(split_dis / sep);
						if(split_dis - sep * total_segs > eps)
						total_segs ++;
						    
						int32 total_pts = total_segs + 1;
						vex_resize(points, total_pts);
						vex_resize(ages, total_pts);
						vex_resize(rads, total_pts);
						vex_resize(dirs, total_pts);
						float dis = 0.f;
						float r = parent_radius;
						FVector3f pos = origin;
						int32 pt_index = 0;
						FVector3f dir = split_dir [ i];
						while(dis < split_dis)
						{
						points [ pt_index] = pos;
						ages [ pt_index] = age_start + dis;
						dirs [ pt_index] = dir;
						dis += sep;
						        
						rads [ pt_index] = r;
						float ramp_pos = dis * inv_split_dis;
						r = parent_radius * RadiusShape.Lookup(ramp_pos);
						        
						        // update dir by force
						if(force > 0.f)
						{
						float strength = ForceRamp.Lookup(ramp_pos);
						dir = vex_normalize(dir + force_dir * force * strength);
						}
						        
						pos += dir * sep;
						        
						++ pt_index;
						}
						    // add last point
						float tail = split_dis - dis + sep;
						if(tail > eps)
						{
						pos = points [ pt_index - 1] + dir * tail;
						float age = ages [ pt_index - 1] + tail;
						points [ pt_index] = pos;
						ages [ pt_index] = age;
						rads [ pt_index] = parent_radius * RadiusShape.Lookup(1.0f);
						dirs [ pt_index] = dir;
						}
						TArray < int32 > pts= vex_addpoints(Geo0, points);
						vex_setpointsattrib(Geo0, "age", pts, ages);
						vex_setpointsattrib(Geo0, "radius", pts, rads);
						vex_setpointsattrib(Geo0, "dir", pts, dirs);
						int32 frac_line = vex_addprim(Geo0, "polyline", pts);
						vex_setprimattrib(Geo0, "frac_level", frac_line, curr_frac_level);
						vex_setprimattrib(Geo0, "oddeven", frac_line, oddeven [ i]);
						}
					}
				}
				
				foreach_begin2->SetPieceResult(piece, frac->GetGeoResult(0));
				delete block_input0;
			}
			foreach_begin2->MergeResult();
		}
	}
	SetGeoResult(UTcrTreeBranchFracLevel::output0, foreach_begin2->GetGeoResult(0));
}

