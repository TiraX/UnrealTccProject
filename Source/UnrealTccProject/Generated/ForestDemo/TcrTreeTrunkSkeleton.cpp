// Auto generated by UnrealTcc. 

#include "TcrTreeTrunkSkeleton.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeTrunkSkeleton::UTcrTreeTrunkSkeleton() 
{
	RscaleAlongCurve.ResizeRampPoints(4);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(0.0485f, 0.6875f);
	RscaleAlongCurve.AddRampPoint(0.5756f, 0.6250f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.6042f);
}
FTccNodePtr UTcrTreeTrunkSkeleton::CreateNode() 
{
	TSharedPtr<FTcrTreeTrunkSkeleton> Node = MakeShared<FTcrTreeTrunkSkeleton>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeTrunkSkeleton::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeTrunkSkeleton> Node = StaticCastSharedPtr<FTcrTreeTrunkSkeleton>(InNode);
	Node->RscaleAlongCurve = RscaleAlongCurve;
	Node->Length = Length;
	Node->Radius = Radius;
	Node->Nseed = Nseed;
	Node->Segs = Segs;
	Node->Freq = Freq;
	Node->Amp = Amp;
	Node->EnableBend = EnableBend;
	Node->Bend = Bend;
}

 FTcrTreeTrunkSkeleton::FTcrTreeTrunkSkeleton() 
{
	InitInputsCount(0);
	tcc_line1 = new FTccLine();
	tcc_line1->InitMultiRefs(false); // RefCount = 1
	enable_noise = new FTccSwitch();
	enable_noise->InitMultiRefs(false); // RefCount = 1
		curl_noise = new FTccVex();
		curl_noise->InitMultiRefs(false); // RefCount = 1
	calc_radius = new FTccVex();
	calc_radius->InitMultiRefs(false); // RefCount = 1
	add_attrib_level = new FTccVex();
	add_attrib_level->InitMultiRefs(false); // RefCount = 1
	enable_bend = new FTccSwitch();
	enable_bend->InitMultiRefs(false); // RefCount = 1
		tcc_bend1 = new FTccBend();
		tcc_bend1->InitMultiRefs(false); // RefCount = 1
		tcc_transform1 = new FTccTransform();
		tcc_transform1->InitMultiRefs(false); // RefCount = 1
	RscaleAlongCurve.ResizeRampPoints(4);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(0.0485f, 0.6875f);
	RscaleAlongCurve.AddRampPoint(0.5756f, 0.6250f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.6042f);
}
 FTcrTreeTrunkSkeleton::~FTcrTreeTrunkSkeleton() 
{
	delete tcc_line1; 
	delete enable_noise; 
		delete curl_noise; 
	delete calc_radius; 
	delete add_attrib_level; 
	delete enable_bend; 
		delete tcc_bend1; 
		delete tcc_transform1; 
}
void FTcrTreeTrunkSkeleton::Cook() 
{
	{
		// Node: tcc_line1
		tcc_line1->Dist = float(Length);
		tcc_line1->Points = int32(Segs);
		tcc_line1->Docurveuattr = 1;
		tcc_line1->Cook();
	}
	{
		// Node: enable_noise
		enable_noise->SetInput(0, tcc_line1);
		enable_noise->Input = int32(Amp > 0);
		enable_noise->NumCases = 2;
		enable_noise->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_noise->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: curl_noise
					curl_noise->SetInput(0, tcc_line1);
					curl_noise->Cook();
					{
						FTccGeometryPtr Geo0 = curl_noise->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						const float freq = Freq;
						const float amp = Amp;
						const int32 seed = Nseed;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector3f pos = _P * freq + float(seed * 6251);
							pos = vex_set(pos.X, pos.Y, pos.Z);
							FVector3f c = vex_curlnoise2d(pos) * amp;
							_P += c * _curveu;
						}
					}
				}
				
				SwitchResult = curl_noise->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_noise->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: calc_radius
		calc_radius->SetInput(0, enable_noise);
		calc_radius->Cook();
		{
			FTccGeometryPtr Geo0 = calc_radius->GetGeoResult(0);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", ETccAttribType::F);
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _curveu = attr_curveu->GetData<float>()[i];
				float& _radius = attr_radius->GetData<float>()[i];
				float p = _curveu;
				float base_r = Radius;
				_radius = RscaleAlongCurve.Lookup(p) * base_r;
			}
		}
	}
	{
		// Node: add_attrib_level
		add_attrib_level->SetInput(0, calc_radius);
		add_attrib_level->Cook();
		{
			FTccGeometryPtr Geo0 = add_attrib_level->GetGeoResult(0);
			vex_setprimattrib(Geo0, "level", 0, 0);
			vex_setdetailattrib(Geo0, "curr_level", 0);
		}
	}
	{
		// Node: enable_bend
		enable_bend->SetInput(0, add_attrib_level);
		enable_bend->Input = int32(EnableBend);
		enable_bend->NumCases = 2;
		enable_bend->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_bend->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_bend1
					tcc_bend1->SetInput(0, add_attrib_level);
					tcc_bend1->Bend = float(Bend);
					tcc_bend1->Dir = FVector3f(0.000000f, 0.000000f, 1.000000f);
					tcc_bend1->Length = float(Length);
					tcc_bend1->Cook();
				}
				
				{
					// Node: tcc_transform1
					tcc_transform1->SetInput(0, tcc_bend1);
					tcc_transform1->R = FVector3f(0.000000f, 0.000000f, 90.000000f);
					tcc_transform1->Cook();
				}
				
				SwitchResult = tcc_transform1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_bend->SetValidGeoResult(0, SwitchResult);
	}
	SetGeoResult(UTcrTreeTrunkSkeleton::output0, enable_bend->GetGeoResult(0));
}

