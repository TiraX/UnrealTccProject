// Auto generated by UnrealTcc. 

#include "TcrTreeBranchSkeleton.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeBranchSkeleton::UTcrTreeBranchSkeleton() 
{
	RscaleAlongCurve.ResizeRampPoints(2);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.5000f);
	LscaleAlongCurve.ResizeRampPoints(2);
	LscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	LscaleAlongCurve.AddRampPoint(1.0000f, 1.0000f);
}
FTccNodePtr UTcrTreeBranchSkeleton::CreateNode() 
{
	TSharedPtr<FTcrTreeBranchSkeleton> Node = MakeShared<FTcrTreeBranchSkeleton>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeBranchSkeleton::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeBranchSkeleton> Node = StaticCastSharedPtr<FTcrTreeBranchSkeleton>(InNode);
	Node->RscaleAlongCurve = RscaleAlongCurve;
	Node->LscaleAlongCurve = LscaleAlongCurve;
	Node->BranchSeed = BranchSeed;
	Node->Npts = Npts;
	Node->Gpercent = Gpercent;
	Node->BranchSegs = BranchSegs;
	Node->EnableDbgColor = EnableDbgColor;
	Node->DbgColor = DbgColor;
	Node->Pattern = Pattern;
	Node->Yaw = Yaw;
	Node->YawRand = YawRand;
	Node->YawRange = YawRange;
	Node->AngleOffset = AngleOffset;
	Node->PitchR = PitchR;
	Node->RadiusScale = RadiusScale;
	Node->Prune = Prune;
	Node->BranchLength = BranchLength;
	Node->EnableNoise = EnableNoise;
	Node->Segs = Segs;
	Node->Freq = Freq;
	Node->Amp = Amp;
	Node->Bend1 = Bend1;
	Node->Bend1Angle = Bend1Angle;
	Node->Bend1Length = Bend1Length;
	Node->Bend1Offset = Bend1Offset;
	Node->Bend2 = Bend2;
	Node->Bend2Angle = Bend2Angle;
	Node->Bend2Length = Bend2Length;
	Node->Bend2Offset = Bend2Offset;
}

 FTcrTreeBranchSkeleton::FTcrTreeBranchSkeleton() 
{
	InitInputsCount(2);
	tcc_blast_by_feature1 = new FTccBlastByFeature();
	tcc_blast_by_feature1->InitMultiRefs(false); // RefCount = 1
	tcc_line1 = new FTccLine();
	tcc_line1->InitMultiRefs(false); // RefCount = 1
	bend1 = new FTccSwitch();
	bend1->InitMultiRefs(false); // RefCount = 1
		tcc_bend1 = new FTccBend();
		tcc_bend1->InitMultiRefs(false); // RefCount = 1
	bend2 = new FTccSwitch();
	bend2->InitMultiRefs(true); // RefCount = 999
		tcc_bend2 = new FTccBend();
		tcc_bend2->InitMultiRefs(false); // RefCount = 1
	foreach_branch = new FTccForBlock();
	foreach_branch->InitMultiRefs(false); // RefCount = 1
	foreach_branch->InitInputsCount(2);
		add_density_calc_dir = new FTccVex();
		add_density_calc_dir->InitMultiRefs(false); // RefCount = 1
		tcc_scatter3 = new FTccScatter();
		tcc_scatter3->InitMultiRefs(false); // RefCount = 1
		delete_density = new FTccAttribDelete();
		delete_density->InitMultiRefs(false); // RefCount = 1
		tcc_sort1 = new FTccSort();
		tcc_sort1->InitMultiRefs(false); // RefCount = 1
		min_max_u = new FTccAttribPromote();
		min_max_u->InitMultiRefs(false); // RefCount = 1
		calc_rotation1 = new FTccVex();
		calc_rotation1->InitMultiRefs(false); // RefCount = 1
		calc_scale = new FTccVex();
		calc_scale->InitMultiRefs(false); // RefCount = 1
		tcc_copy_to_point1 = new FTccCopyToPoint();
		tcc_copy_to_point1->InitMultiRefs(false); // RefCount = 1
	add_primattrib_level = new FTccVex();
	add_primattrib_level->InitMultiRefs(false); // RefCount = 1
	prune = new FTccSwitch();
	prune->InitMultiRefs(false); // RefCount = 1
		tcc_carve_by_volume1 = new FTccCarveByVolume();
		tcc_carve_by_volume1->InitMultiRefs(false); // RefCount = 1
	calc_radius = new FTccVex();
	calc_radius->InitMultiRefs(false); // RefCount = 1
	enable_noise = new FTccSwitch();
	enable_noise->InitMultiRefs(false); // RefCount = 1
		tcc_resample1 = new FTccResample();
		tcc_resample1->InitMultiRefs(false); // RefCount = 1
		curl_noise = new FTccVex();
		curl_noise->InitMultiRefs(false); // RefCount = 1
	dbg_color = new FTccSwitch();
	dbg_color->InitMultiRefs(false); // RefCount = 1
		tcc_vex1 = new FTccVex();
		tcc_vex1->InitMultiRefs(false); // RefCount = 1
	tcc_merge1 = new FTccMerge();
	tcc_merge1->InitMultiRefs(false); // RefCount = 1
	inc_curr_level = new FTccVex();
	inc_curr_level->InitMultiRefs(false); // RefCount = 1
	RscaleAlongCurve.ResizeRampPoints(2);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.5000f);
	LscaleAlongCurve.ResizeRampPoints(2);
	LscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	LscaleAlongCurve.AddRampPoint(1.0000f, 1.0000f);
}
 FTcrTreeBranchSkeleton::~FTcrTreeBranchSkeleton() 
{
	delete tcc_blast_by_feature1; 
	delete tcc_line1; 
	delete bend1; 
		delete tcc_bend1; 
	delete bend2; 
		delete tcc_bend2; 
	delete foreach_branch; 
		delete add_density_calc_dir; 
		delete tcc_scatter3; 
		delete delete_density; 
		delete tcc_sort1; 
		delete min_max_u; 
		delete calc_rotation1; 
		delete calc_scale; 
		delete tcc_copy_to_point1; 
	delete add_primattrib_level; 
	delete prune; 
		delete tcc_carve_by_volume1; 
	delete calc_radius; 
	delete enable_noise; 
		delete tcc_resample1; 
		delete curl_noise; 
	delete dbg_color; 
		delete tcc_vex1; 
	delete tcc_merge1; 
	delete inc_curr_level; 
}
void FTcrTreeBranchSkeleton::Cook() 
{
	{
		// Node: tcc_blast_by_feature1
		tcc_blast_by_feature1->SetInput(0, GetInput(0));
		FTccGeometryConstPtr Geo0 = tcc_blast_by_feature1->GetInput(0)->GetConstGeoResult(0);
		tcc_blast_by_feature1->ByAttrib = 1;
		tcc_blast_by_feature1->Attrib = TEXT("level");
		tcc_blast_by_feature1->Op = UTccBlastByFeature::NotEqual;
		tcc_blast_by_feature1->Value = float(hs_detail(Geo0, "curr_level", 0));
		tcc_blast_by_feature1->Cook();
	}
	{
		// Node: tcc_line1
		tcc_line1->Dir = FVector3f(0.000000f, 1.000000f, 0.000000f);
		tcc_line1->Dist = float(BranchLength);
		tcc_line1->Points = int32(BranchSegs);
		tcc_line1->Docurveuattr = 1;
		tcc_line1->Cook();
	}
	{
		// Node: bend1
		bend1->SetInput(0, tcc_line1);
		bend1->Input = int32(Bend1);
		bend1->NumCases = 2;
		bend1->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = bend1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_bend1
					tcc_bend1->SetInput(0, tcc_line1);
					tcc_bend1->Bend = float(Bend1Angle);
					tcc_bend1->Origin = FVector3f(0.000000f, Bend1Offset, 0.000000f);
					tcc_bend1->Length = float(BranchLength * Bend1Length);
					tcc_bend1->Cook();
				}
				
				SwitchResult = tcc_bend1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		bend1->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: bend2
		bend2->SetInput(0, bend1);
		bend2->Input = int32(Bend2);
		bend2->NumCases = 2;
		bend2->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = bend2->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_bend2
					tcc_bend2->SetInput(0, bend1);
					tcc_bend2->Bend = float(Bend2Angle);
					tcc_bend2->Origin = FVector3f(0.000000f, Bend2Offset, 0.000000f);
					tcc_bend2->Length = float(BranchLength * Bend2Length);
					tcc_bend2->Cook();
				}
				
				SwitchResult = tcc_bend2->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		bend2->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: foreach_branch
		foreach_branch->SetInput(0, tcc_blast_by_feature1);
		foreach_branch->SetInput(1, bend2);
		foreach_branch->Itermethod = UTccForBlock::ByPiecesOrPoints;
		foreach_branch->Method = UTccForBlock::MergeEachIteration;
		foreach_branch->Class = UTccForBlock::Primitives;
		foreach_branch->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = foreach_branch->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				FTccNode* block_input0 = new FTccNode();
				block_input0->SetGeoResult(0, foreach_branch->GetGeometryPiece(piece));
				FTccNode* block_input1 = bend2;
				{
					// Node: add_density_calc_dir
					add_density_calc_dir->SetInput(0, block_input0);
					add_density_calc_dir->Cook();
					{
						FTccGeometryPtr Geo0 = add_density_calc_dir->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						FTccAttribPtr attr_density = Geo0->AddPointAttrib("density", ETccAttribType::F);
						FTccAttribPtr attr_tangent = Geo0->AddPointAttrib("tangent", ETccAttribType::F3);
						const FVector2f percent = Gpercent;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _curveu = attr_curveu->GetData<float>()[i];
							float& _density = attr_density->GetData<float>()[i];
							FVector3f& _tangent = attr_tangent->GetData<FVector3f>()[i];
							// calc density
							float f = _curveu;
							_density = (f >= percent.X && f <= percent.Y)? 1.f : 0.f;
							// calc tangent dir
							FVector3f p0, p1;
							if(_ptnum == _numpt - 1)
							{
							    // last point
							p0 = vex_pointp(Geo0, _ptnum - 1);
							p1 = vex_pointp(Geo0, _ptnum);
							}
							else if(_ptnum == 0)
							{
							    // first point
							p0 = vex_pointp(Geo0, _ptnum);
							p1 = vex_pointp(Geo0, _ptnum + 1);
							}
							else
							{
							    // other points
							p0 = vex_pointp(Geo0, _ptnum - 1);
							p1 = vex_pointp(Geo0, _ptnum + 1);
							}
							FVector3f yaw_axis = vex_normalize(p1 - p0);
							_tangent = yaw_axis;
						}
					}
				}
				
				{
					// Node: tcc_scatter3
					tcc_scatter3->SetInput(0, add_density_calc_dir);
					tcc_scatter3->Usedensityattrib = 1;
					tcc_scatter3->Npts = int32(Npts);
					tcc_scatter3->ScatterSeed = int32(BranchSeed);
					tcc_scatter3->Cook();
				}
				
				{
					// Node: delete_density
					delete_density->SetInput(0, tcc_scatter3);
					delete_density->Ptdel = TEXT("density");
					delete_density->Cook();
				}
				
				{
					// Node: tcc_sort1
					tcc_sort1->SetInput(0, delete_density);
					tcc_sort1->Ptsort = UTccSort::ByAttribute;
					tcc_sort1->Pointattrib = TEXT("curveu");
					tcc_sort1->Cook();
				}
				
				{
					// Node: min_max_u
					min_max_u->SetInput(0, tcc_sort1);
					min_max_u->Inname = TEXT("curveu");
					min_max_u->Outclass = UTccAttribPromote::DetailOnlyOnce;
					min_max_u->DoMax = 1;
					min_max_u->DoMin = 1;
					min_max_u->Cook();
				}
				
				{
					// Node: calc_rotation1
					calc_rotation1->SetInput(0, min_max_u);
					calc_rotation1->SetInput(1, nullptr);
					calc_rotation1->Cook();
					{
						FTccGeometryPtr Geo0 = calc_rotation1->GetGeoResult(0);
						FTccAttribPtr attr_tangent = Geo0->AddPointAttrib("tangent", ETccAttribType::F3);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
						const float angle_step = vex_radians(Yaw);
						const FVector2f pitch_r = vex_radians(PitchR);
						const int32 gseed = BranchSeed;
						const int32 iter = _iteration;
						const int32 pattern = Pattern;
						const float yaw_rand = vex_radians(YawRand);
						const float yaw_range = vex_radians(YawRange);
						const float angle_offset = vex_radians(AngleOffset);
						const float num_pt_inv = 1.0f / vex_npoints(Geo0);
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _tangent = attr_tangent->GetData<FVector3f>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							// calc yaw by pattern
							float yaw = 0;
							if(pattern == 0)
							{
							yaw = angle_step * _ptnum + angle_offset;
							    // angle step
							float yaw_r = vex_fit01(vex_rand(gseed * iter + _ptnum + 42),  - yaw_rand, yaw_rand);
							yaw += yaw_r;
							}
							else
							{
							    // angle range
							float yaw_step = yaw_range * 2 * num_pt_inv * 2;
							yaw = yaw_step * _ptnum + angle_offset;
							if(yaw_range > 0)
							yaw = vex_fmod(yaw, yaw_range * 2);
							yaw += angle_step - yaw_range;
							    //yaw -= yaw_range;
							}
							FVector3f yaw_axis = _tangent;
							// calc rotated normal
							FVector3f n = vex_set(0, 1, 0);
							// if n and axis locate in same direction, change n to axis-z
							if(abs(vex_dot(n, yaw_axis))> 0.99f)n = vex_set(1, 0, 0);
							n = vex_cross(n, yaw_axis);
							n = vex_cross(yaw_axis, n);
							FVector4f q = vex_quaternion(yaw, yaw_axis);
							n = vex_qrotate(q, n);
							//@N = n;
							//f@L = length(@N);
							FVector3f pitch_axis = vex_normalize(vex_cross(n, yaw_axis));
							float pitch = vex_fit(_curveu, min_u, max_u, pitch_r.X, pitch_r.Y);
							FVector4f q1 = vex_quaternion(pitch, pitch_axis);
							n = vex_normalize(vex_qrotate(q1, n));
							FMatrix44f m3 = vex_maketransform(n, yaw_axis);
							_orient = vex_quaternion(m3);
						}
					}
				}
				
				{
					// Node: calc_scale
					calc_scale->SetInput(0, calc_rotation1);
					calc_scale->Cook();
					{
						FTccGeometryPtr Geo0 = calc_scale->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", ETccAttribType::F);
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const float inv_u_dis = 1.f / (max_u - min_u);
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _curveu = attr_curveu->GetData<float>()[i];
							float& _pscale = attr_pscale->GetData<float>()[i];
							float p = (_curveu - min_u) * inv_u_dis;
							_pscale = LscaleAlongCurve.Lookup(p);
						}
					}
				}
				
				{
					// Node: tcc_copy_to_point1
					tcc_copy_to_point1->SetInput(0, block_input1);
					tcc_copy_to_point1->SetInput(1, calc_scale);
					tcc_copy_to_point1->AttribToPoints = TEXT("radius");
					tcc_copy_to_point1->Cook();
				}
				
				foreach_branch->SetPieceResult(piece, tcc_copy_to_point1->GetGeoResult(0));
				delete block_input0;
			}
			foreach_branch->MergeResult();
		}
	}
	{
		// Node: add_primattrib_level
		add_primattrib_level->SetInput(0, foreach_branch);
		add_primattrib_level->SetInput(1, GetInput(0));
		add_primattrib_level->Cook();
		{
			FTccGeometryPtr Geo0 = add_primattrib_level->GetGeoResult(0);
			FTccGeometryConstPtr Geo1 = GetInput(0)->GetConstGeoResult(0);
			FTccAttribPtr attr_level = Geo0->AddPrimAttrib("level", ETccAttribType::I);
			const int32 _numprim = Geo0->GetNumPrims();
			for(int32 i = 0; i < _numprim; i++)
			{
				const int32 _primnum = i;
				int32& _level = attr_level->GetData<int32>()[i];
				int32 curr_level = vex_detaili(Geo1, "curr_level");
				_level = curr_level + 1;
			}
		}
	}
	{
		// Node: prune
		prune->SetInput(0, add_primattrib_level);
		prune->Input = int32(Prune);
		prune->NumCases = 2;
		prune->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = prune->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_carve_by_volume1
					tcc_carve_by_volume1->SetInput(0, add_primattrib_level);
					tcc_carve_by_volume1->SetInput(1, GetInput(1));
					tcc_carve_by_volume1->Start = 0;
					tcc_carve_by_volume1->Docurveuattr = 1;
					tcc_carve_by_volume1->Cook();
				}
				
				SwitchResult = tcc_carve_by_volume1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		prune->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: calc_radius
		calc_radius->SetInput(0, prune);
		calc_radius->Cook();
		{
			FTccGeometryPtr Geo0 = calc_radius->GetGeoResult(0);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", ETccAttribType::F);
			const float radius_scale = RadiusScale;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _curveu = attr_curveu->GetData<float>()[i];
				float& _radius = attr_radius->GetData<float>()[i];
				float p = _curveu;
				float base_r = _radius;
				_radius = RscaleAlongCurve.Lookup(p) * base_r * radius_scale;
			}
		}
	}
	{
		// Node: enable_noise
		enable_noise->SetInput(0, calc_radius);
		enable_noise->Input = int32(EnableNoise);
		enable_noise->NumCases = 2;
		enable_noise->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_noise->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_resample1
					tcc_resample1->SetInput(0, calc_radius);
					tcc_resample1->Dolength = 0;
					tcc_resample1->Dosegs = 1;
					tcc_resample1->Segs = int32(Segs);
					tcc_resample1->Cook();
				}
				
				{
					// Node: curl_noise
					curl_noise->SetInput(0, tcc_resample1);
					curl_noise->Cook();
					{
						FTccGeometryPtr Geo0 = curl_noise->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						const float freq = Freq;
						const float amp = Amp;
						const int32 seed = BranchSeed;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector3f pos = _P * freq + float(seed * 3241);
							FVector3f c = vex_curlnoise2d(pos) * amp;
							_P += c * _curveu;
						}
					}
				}
				
				SwitchResult = curl_noise->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_noise->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: dbg_color
		dbg_color->SetInput(0, enable_noise);
		dbg_color->Input = int32(EnableDbgColor);
		dbg_color->NumCases = 2;
		dbg_color->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = dbg_color->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_vex1
					tcc_vex1->SetInput(0, enable_noise);
					tcc_vex1->Cook();
					{
						FTccGeometryPtr Geo0 = tcc_vex1->GetGeoResult(0);
						FTccAttribPtr attr_Cd = Geo0->AddPointAttrib("Cd", ETccAttribType::F3);
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _Cd = attr_Cd->GetData<FVector3f>()[i];
							_Cd = DbgColor;
						}
					}
				}
				
				SwitchResult = tcc_vex1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		dbg_color->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: tcc_merge1
		tcc_merge1->SetInput(0, dbg_color);
		tcc_merge1->SetInput(1, GetInput(0));
		tcc_merge1->Cook();
	}
	{
		// Node: inc_curr_level
		inc_curr_level->SetInput(0, tcc_merge1);
		inc_curr_level->Cook();
		{
			FTccGeometryPtr Geo0 = inc_curr_level->GetGeoResult(0);
			FTccAttribPtr attr_curr_level = Geo0->AddDetailAttrib("curr_level", ETccAttribType::I);
			int32& _curr_level = attr_curr_level->GetData<int32>()[0];
			_curr_level += 1;
		}
	}
	SetGeoResult(UTcrTreeBranchSkeleton::output0, inc_curr_level->GetGeoResult(0));
}

