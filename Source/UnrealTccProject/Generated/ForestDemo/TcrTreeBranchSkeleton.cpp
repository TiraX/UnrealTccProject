// Auto generated by UnrealTcc. 

#include "TcrTreeBranchSkeleton.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeBranchSkeleton::UTcrTreeBranchSkeleton() 
{
	RscaleAlongCurve.ResizeRampPoints(2);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.5000f);
	LscaleAlongCurve.ResizeRampPoints(2);
	LscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	LscaleAlongCurve.AddRampPoint(1.0000f, 1.0000f);
}
FTccNodePtr UTcrTreeBranchSkeleton::CreateNode() 
{
	TSharedPtr<FTcrTreeBranchSkeleton> Node = MakeShared<FTcrTreeBranchSkeleton>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeBranchSkeleton::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeBranchSkeleton> Node = StaticCastSharedPtr<FTcrTreeBranchSkeleton>(InNode);
	Node->RscaleAlongCurve = RscaleAlongCurve;
	Node->LscaleAlongCurve = LscaleAlongCurve;
	Node->BranchSeed = BranchSeed;
	Node->Method = Method;
	Node->Npts = Npts;
	Node->Distance = Distance;
	Node->Gpercent = Gpercent;
	Node->BranchSegs = BranchSegs;
	Node->EnableDbgColor = EnableDbgColor;
	Node->DbgColor = DbgColor;
	Node->Pattern = Pattern;
	Node->Yaw = Yaw;
	Node->YawRand = YawRand;
	Node->YawRange = YawRange;
	Node->AngleOffset = AngleOffset;
	Node->PitchR = PitchR;
	Node->RadiusScale = RadiusScale;
	Node->ByVolume = ByVolume;
	Node->BranchLength = BranchLength;
	Node->EnableNoise = EnableNoise;
	Node->Freq = Freq;
	Node->Amp = Amp;
	Node->Bend1 = Bend1;
	Node->Bend1Angle = Bend1Angle;
	Node->Bend1Length = Bend1Length;
	Node->Bend1Offset = Bend1Offset;
	Node->Bend2 = Bend2;
	Node->Bend2Angle = Bend2Angle;
	Node->Bend2Length = Bend2Length;
	Node->Bend2Offset = Bend2Offset;
}

 FTcrTreeBranchSkeleton::FTcrTreeBranchSkeleton() 
{
	InitInputsCount(2);
	tcc_blast_by_feature1 = new FTccBlastByFeature();
	tcc_blast_by_feature1->InitMultiRefs(false); // RefCount = 1
	remove_under_min = new FTccBlastByFeature();
	remove_under_min->InitMultiRefs(false); // RefCount = 1
	remove_above_max = new FTccBlastByFeature();
	remove_above_max->InitMultiRefs(false); // RefCount = 1
	tcc_measure1 = new FTccMeasure();
	tcc_measure1->InitMultiRefs(false); // RefCount = 1
	remove_0_len = new FTccBlastByFeature();
	remove_0_len->InitMultiRefs(false); // RefCount = 1
	tangent = new FTccPolyFrame();
	tangent->InitMultiRefs(false); // RefCount = 1
	by_volume_more_length = new FTccSwitch();
	by_volume_more_length->InitMultiRefs(false); // RefCount = 1
		tcc_line1 = new FTccLine();
		tcc_line1->InitMultiRefs(false); // RefCount = 1
		tcc_line_double = new FTccLine();
		tcc_line_double->InitMultiRefs(false); // RefCount = 1
	bend1 = new FTccSwitch();
	bend1->InitMultiRefs(false); // RefCount = 1
		tcc_bend1 = new FTccBend();
		tcc_bend1->InitMultiRefs(false); // RefCount = 1
	bend2 = new FTccSwitch();
	bend2->InitMultiRefs(true); // RefCount = 999
		tcc_bend2 = new FTccBend();
		tcc_bend2->InitMultiRefs(false); // RefCount = 1
	foreach_branch = new FTccForBlock();
	foreach_branch->InitMultiRefs(false); // RefCount = 1
	foreach_branch->InitInputsCount(2);
		calc_count_and_seed = new FTccVex();
		calc_count_and_seed->InitMultiRefs(false); // RefCount = 1
		tcc_dithered_scatter1 = new FTccDitheredScatter();
		tcc_dithered_scatter1->InitMultiRefs(false); // RefCount = 1
		tcc_sort1 = new FTccSort();
		tcc_sort1->InitMultiRefs(false); // RefCount = 1
		min_max_u = new FTccAttribPromote();
		min_max_u->InitMultiRefs(false); // RefCount = 1
		calc_rotation1 = new FTccVex();
		calc_rotation1->InitMultiRefs(false); // RefCount = 1
		calc_scale = new FTccVex();
		calc_scale->InitMultiRefs(false); // RefCount = 1
		tcc_copy_to_point1 = new FTccCopyToPoint();
		tcc_copy_to_point1->InitMultiRefs(false); // RefCount = 1
	add_primattrib_level = new FTccVex();
	add_primattrib_level->InitMultiRefs(false); // RefCount = 1
	prune_by_volume = new FTccSwitch();
	prune_by_volume->InitMultiRefs(false); // RefCount = 1
		tcc_carve_by_volume1 = new FTccCarveByVolume();
		tcc_carve_by_volume1->InitMultiRefs(false); // RefCount = 1
	calc_radius = new FTccVex();
	calc_radius->InitMultiRefs(false); // RefCount = 1
	enable_noise = new FTccSwitch();
	enable_noise->InitMultiRefs(false); // RefCount = 1
		curl_noise = new FTccVex();
		curl_noise->InitMultiRefs(false); // RefCount = 1
	dbg_color = new FTccSwitch();
	dbg_color->InitMultiRefs(false); // RefCount = 1
		tcc_vex1 = new FTccVex();
		tcc_vex1->InitMultiRefs(false); // RefCount = 1
	tcc_merge1 = new FTccMerge();
	tcc_merge1->InitMultiRefs(false); // RefCount = 1
	inc_curr_level = new FTccVex();
	inc_curr_level->InitMultiRefs(false); // RefCount = 1
	RscaleAlongCurve.ResizeRampPoints(2);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.5000f);
	LscaleAlongCurve.ResizeRampPoints(2);
	LscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	LscaleAlongCurve.AddRampPoint(1.0000f, 1.0000f);
}
 FTcrTreeBranchSkeleton::~FTcrTreeBranchSkeleton() 
{
	delete tcc_blast_by_feature1; 
	delete remove_under_min; 
	delete remove_above_max; 
	delete tcc_measure1; 
	delete remove_0_len; 
	delete tangent; 
	delete by_volume_more_length; 
		delete tcc_line1; 
		delete tcc_line_double; 
	delete bend1; 
		delete tcc_bend1; 
	delete bend2; 
		delete tcc_bend2; 
	delete foreach_branch; 
		delete calc_count_and_seed; 
		delete tcc_dithered_scatter1; 
		delete tcc_sort1; 
		delete min_max_u; 
		delete calc_rotation1; 
		delete calc_scale; 
		delete tcc_copy_to_point1; 
	delete add_primattrib_level; 
	delete prune_by_volume; 
		delete tcc_carve_by_volume1; 
	delete calc_radius; 
	delete enable_noise; 
		delete curl_noise; 
	delete dbg_color; 
		delete tcc_vex1; 
	delete tcc_merge1; 
	delete inc_curr_level; 
}
void FTcrTreeBranchSkeleton::Cook() 
{
	{
		// Node: tcc_blast_by_feature1
		tcc_blast_by_feature1->SetInput(0, GetInput(0));
		FTccGeometryConstPtr Geo0 = tcc_blast_by_feature1->GetInput(0)->GetConstGeoResult(0);
		tcc_blast_by_feature1->ByAttrib = 1;
		tcc_blast_by_feature1->Attrib = TEXT("level");
		tcc_blast_by_feature1->Op = UTccBlastByFeature::NotEqual;
		tcc_blast_by_feature1->Value = float(hs_detail(Geo0, "curr_level", 0));
		tcc_blast_by_feature1->Cook();
	}
	{
		// Node: remove_under_min
		remove_under_min->SetInput(0, tcc_blast_by_feature1);
		remove_under_min->Grouptype = UTccBlastByFeature::Points;
		remove_under_min->ByAttrib = 1;
		remove_under_min->Attrib = TEXT("curveu");
		remove_under_min->Op = UTccBlastByFeature::Less;
		remove_under_min->Value = float(Gpercent.X);
		remove_under_min->Cook();
	}
	{
		// Node: remove_above_max
		remove_above_max->SetInput(0, remove_under_min);
		remove_above_max->Grouptype = UTccBlastByFeature::Points;
		remove_above_max->ByAttrib = 1;
		remove_above_max->Attrib = TEXT("curveu");
		remove_above_max->Op = UTccBlastByFeature::Greater;
		remove_above_max->Value = float(Gpercent.Y);
		remove_above_max->Cook();
	}
	{
		// Node: tcc_measure1
		tcc_measure1->SetInput(0, remove_above_max);
		tcc_measure1->Measure = UTccMeasure::Perimeter;
		tcc_measure1->Attribname = TEXT("length");
		tcc_measure1->Cook();
	}
	{
		// Node: remove_0_len
		remove_0_len->SetInput(0, tcc_measure1);
		remove_0_len->ByAttrib = 1;
		remove_0_len->Attrib = TEXT("length");
		remove_0_len->Cook();
	}
	{
		// Node: tangent
		tangent->SetInput(0, remove_0_len);
		tangent->Tangentu = TEXT("tangent");
		tangent->Cook();
	}
	{
		// Node: by_volume_more_length
		by_volume_more_length->Input = int32(ByVolume);
		by_volume_more_length->NumCases = 2;
		by_volume_more_length->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = by_volume_more_length->Input;
		switch (Selection)
		{
			case 0:
			{
				{
					// Node: tcc_line1
					tcc_line1->Dir = FVector3f(0.000000f, 1.000000f, 0.000000f);
					tcc_line1->Dist = float(BranchLength);
					tcc_line1->Points = int32(BranchSegs);
					tcc_line1->Docurveuattr = 1;
					tcc_line1->Cook();
				}
				
				
				SwitchResult = tcc_line1->GetGeoResult(0);
			}
			break;
			case 1:
			{
				
				{
					// Node: tcc_line_double
					tcc_line_double->Dir = FVector3f(0.000000f, 1.000000f, 0.000000f);
					tcc_line_double->Dist = float(BranchLength * 2);
					tcc_line_double->Points = int32(BranchSegs * 2);
					tcc_line_double->Docurveuattr = 1;
					tcc_line_double->Cook();
				}
				
				SwitchResult = tcc_line_double->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		by_volume_more_length->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: bend1
		bend1->SetInput(0, by_volume_more_length);
		bend1->Input = int32(Bend1);
		bend1->NumCases = 2;
		bend1->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = bend1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_bend1
					tcc_bend1->SetInput(0, by_volume_more_length);
					tcc_bend1->Bend = float(Bend1Angle);
					tcc_bend1->Origin = FVector3f(0.000000f, Bend1Offset, 0.000000f);
					tcc_bend1->Length = float(BranchLength * Bend1Length);
					tcc_bend1->Cook();
				}
				
				SwitchResult = tcc_bend1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		bend1->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: bend2
		bend2->SetInput(0, bend1);
		bend2->Input = int32(Bend2);
		bend2->NumCases = 2;
		bend2->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = bend2->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_bend2
					tcc_bend2->SetInput(0, bend1);
					tcc_bend2->Bend = float(Bend2Angle);
					tcc_bend2->Origin = FVector3f(0.000000f, Bend2Offset, 0.000000f);
					tcc_bend2->Length = float(BranchLength * Bend2Length);
					tcc_bend2->Cook();
				}
				
				SwitchResult = tcc_bend2->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		bend2->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: foreach_branch
		foreach_branch->SetInput(0, tangent);
		foreach_branch->SetInput(1, bend2);
		foreach_branch->Itermethod = UTccForBlock::ByPiecesOrPoints;
		foreach_branch->Method = UTccForBlock::MergeEachIteration;
		foreach_branch->Class = UTccForBlock::Primitives;
		foreach_branch->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = foreach_branch->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				FTccNode* block_input0 = new FTccNode();
				block_input0->SetGeoResult(0, foreach_branch->GetGeometryPiece(piece));
				FTccNode* block_input1 = bend2;
				{
					// Node: calc_count_and_seed
					calc_count_and_seed->SetInput(0, block_input0);
					calc_count_and_seed->SetInput(1, nullptr);
					calc_count_and_seed->Cook();
					{
						FTccGeometryPtr Geo0 = calc_count_and_seed->GetGeoResult(0);
						FTccAttribPtr attr_total_count = Geo0->AddDetailAttrib("total_count", ETccAttribType::I);
						FTccAttribPtr attr_seed = Geo0->AddDetailAttrib("seed", ETccAttribType::I);
						const int32 method = Method;
						const int32 npts = Npts;
						const float distance = Distance;
						const int32 bseed = BranchSeed;
						int32& _total_count = attr_total_count->GetData<int32>()[0];
						int32& _seed = attr_seed->GetData<int32>()[0];
						int32 count = 0;
						if(method == 1)
						{
						    // by distance
						float l = vex_primf(Geo0, "length", 0);
						count = (int)(l / distance + 0.5f);
						}
						else
						{
						    // by count
						count = npts;
						}
						_total_count = count;
						int32 iter = _iteration;
						_seed = bseed + iter * 4;
					}
				}
				
				{
					// Node: tcc_dithered_scatter1
					tcc_dithered_scatter1->SetInput(0, calc_count_and_seed);
					FTccGeometryConstPtr Geo0 = tcc_dithered_scatter1->GetInput(0)->GetConstGeoResult(0);
					tcc_dithered_scatter1->Npts = int32(hs_detail(Geo0, "total_count", 0));
					tcc_dithered_scatter1->ScatterSeed = int32(hs_detail(Geo0, "seed", 0));
					tcc_dithered_scatter1->Jitter = 0.063000f;
					tcc_dithered_scatter1->Cook();
				}
				
				{
					// Node: tcc_sort1
					tcc_sort1->SetInput(0, tcc_dithered_scatter1);
					tcc_sort1->Ptsort = UTccSort::ByAttribute;
					tcc_sort1->Pointattrib = TEXT("curveu");
					tcc_sort1->Cook();
				}
				
				{
					// Node: min_max_u
					min_max_u->SetInput(0, tcc_sort1);
					min_max_u->Inname = TEXT("curveu");
					min_max_u->Outclass = UTccAttribPromote::DetailOnlyOnce;
					min_max_u->DoMax = 1;
					min_max_u->DoMin = 1;
					min_max_u->Cook();
				}
				
				{
					// Node: calc_rotation1
					calc_rotation1->SetInput(0, min_max_u);
					calc_rotation1->SetInput(1, nullptr);
					calc_rotation1->Cook();
					{
						FTccGeometryPtr Geo0 = calc_rotation1->GetGeoResult(0);
						FTccAttribPtr attr_tangent = Geo0->AddPointAttrib("tangent", ETccAttribType::F3);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
						const float angle_step = vex_radians(Yaw);
						const FVector2f pitch_r = vex_radians(PitchR);
						const int32 gseed = BranchSeed;
						const int32 iter = _iteration;
						const int32 pattern = Pattern;
						const float yaw_rand = vex_radians(YawRand);
						const float yaw_range = vex_radians(YawRange);
						const float angle_offset = vex_radians(AngleOffset);
						const float num_pt_inv = 1.0f / vex_npoints(Geo0);
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _tangent = attr_tangent->GetData<FVector3f>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							// calc yaw by pattern
							float yaw = 0;
							if(pattern == 0)
							{
							yaw = angle_step * _ptnum + angle_offset;
							    // angle step
							float yaw_r = vex_fit01(vex_rand(gseed * iter + _ptnum + 42),  - yaw_rand, yaw_rand);
							yaw += yaw_r;
							}
							else
							{
							    // angle range
							float yaw_step = yaw_range * 2 * num_pt_inv * 2;
							yaw = yaw_step * _ptnum + angle_offset;
							if(yaw_range > 0)
							yaw = vex_fmod(yaw, yaw_range * 2);
							yaw += angle_step - yaw_range;
							    //yaw -= yaw_range;
							}
							FVector3f yaw_axis =  - _tangent;
							// calc rotated normal
							FVector3f n = vex_set(0, 1, 0);
							// if n and axis locate in same direction, change n to axis-z
							if(abs(vex_dot(n, yaw_axis))> 0.99f)n = vex_set(1, 0, 0);
							n = vex_cross(n, yaw_axis);
							n = vex_cross(yaw_axis, n);
							FVector4f q = vex_quaternion(yaw, yaw_axis);
							n = vex_qrotate(q, n);
							//@N = n;
							//f@L = length(@N);
							FVector3f pitch_axis = vex_normalize(vex_cross(n, yaw_axis));
							float pitch_percent = vex_fit(_curveu, min_u, max_u, 0, 1);
							pitch_percent = pitch_percent * pitch_percent;
							float pitch = vex_fit01(pitch_percent, pitch_r.X, pitch_r.Y);
							//float pitch = fit(f@curveu, min_u, max_u, pitch_r.x, pitch_r.y);
							FVector4f q1 = vex_quaternion(pitch, pitch_axis);
							n = vex_normalize(vex_qrotate(q1, n));
							FMatrix44f m3 = vex_maketransform(n, yaw_axis);
							_orient = vex_quaternion(m3);
						}
					}
				}
				
				{
					// Node: calc_scale
					calc_scale->SetInput(0, calc_rotation1);
					calc_scale->Cook();
					{
						FTccGeometryPtr Geo0 = calc_scale->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", ETccAttribType::F);
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const float inv_u_dis = 1.f / (max_u - min_u);
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _curveu = attr_curveu->GetData<float>()[i];
							float& _pscale = attr_pscale->GetData<float>()[i];
							float p = (_curveu - min_u) * inv_u_dis;
							_pscale = LscaleAlongCurve.Lookup(p);
						}
					}
				}
				
				{
					// Node: tcc_copy_to_point1
					tcc_copy_to_point1->SetInput(0, block_input1);
					tcc_copy_to_point1->SetInput(1, calc_scale);
					tcc_copy_to_point1->AttribToPoints = TEXT("radius");
					tcc_copy_to_point1->Cook();
				}
				
				foreach_branch->SetPieceResult(piece, tcc_copy_to_point1->GetGeoResult(0));
				delete block_input0;
			}
			foreach_branch->MergeResult();
		}
	}
	{
		// Node: add_primattrib_level
		add_primattrib_level->SetInput(0, foreach_branch);
		add_primattrib_level->SetInput(1, GetInput(0));
		add_primattrib_level->Cook();
		{
			FTccGeometryPtr Geo0 = add_primattrib_level->GetGeoResult(0);
			FTccGeometryConstPtr Geo1 = GetInput(0)->GetConstGeoResult(0);
			FTccAttribPtr attr_level = Geo0->AddPrimAttrib("level", ETccAttribType::I);
			const int32 _numprim = Geo0->GetNumPrims();
			for(int32 i = 0; i < _numprim; i++)
			{
				const int32 _primnum = i;
				int32& _level = attr_level->GetData<int32>()[i];
				int32 curr_level = vex_detaili(Geo1, "curr_level");
				_level = curr_level + 1;
			}
		}
	}
	{
		// Node: prune_by_volume
		prune_by_volume->SetInput(0, add_primattrib_level);
		prune_by_volume->Input = int32(ByVolume);
		prune_by_volume->NumCases = 2;
		prune_by_volume->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = prune_by_volume->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_carve_by_volume1
					tcc_carve_by_volume1->SetInput(0, add_primattrib_level);
					tcc_carve_by_volume1->SetInput(1, GetInput(1));
					tcc_carve_by_volume1->Start = 0;
					tcc_carve_by_volume1->Docurveuattr = 1;
					tcc_carve_by_volume1->Cook();
				}
				
				SwitchResult = tcc_carve_by_volume1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		prune_by_volume->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: calc_radius
		calc_radius->SetInput(0, prune_by_volume);
		calc_radius->Cook();
		{
			FTccGeometryPtr Geo0 = calc_radius->GetGeoResult(0);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", ETccAttribType::F);
			const float radius_scale = RadiusScale;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _curveu = attr_curveu->GetData<float>()[i];
				float& _radius = attr_radius->GetData<float>()[i];
				float p = _curveu;
				float base_r = _radius;
				_radius = RscaleAlongCurve.Lookup(p) * base_r * radius_scale;
			}
		}
	}
	{
		// Node: enable_noise
		enable_noise->SetInput(0, calc_radius);
		enable_noise->Input = int32(EnableNoise);
		enable_noise->NumCases = 2;
		enable_noise->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_noise->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: curl_noise
					curl_noise->SetInput(0, calc_radius);
					curl_noise->Cook();
					{
						FTccGeometryPtr Geo0 = curl_noise->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						const float freq = Freq;
						const float amp = Amp;
						const int32 seed = BranchSeed;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector3f pos = _P * freq + float(seed * 3241);
							FVector3f c = vex_curlnoise2d(pos) * amp;
							_P += c * _curveu;
						}
					}
				}
				
				SwitchResult = curl_noise->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_noise->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: dbg_color
		dbg_color->SetInput(0, enable_noise);
		dbg_color->Input = int32(EnableDbgColor);
		dbg_color->NumCases = 2;
		dbg_color->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = dbg_color->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_vex1
					tcc_vex1->SetInput(0, enable_noise);
					tcc_vex1->Cook();
					{
						FTccGeometryPtr Geo0 = tcc_vex1->GetGeoResult(0);
						FTccAttribPtr attr_Cd = Geo0->AddPointAttrib("Cd", ETccAttribType::F3);
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _Cd = attr_Cd->GetData<FVector3f>()[i];
							_Cd = DbgColor;
						}
					}
				}
				
				SwitchResult = tcc_vex1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		dbg_color->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: tcc_merge1
		tcc_merge1->SetInput(0, dbg_color);
		tcc_merge1->SetInput(1, GetInput(0));
		tcc_merge1->Cook();
	}
	{
		// Node: inc_curr_level
		inc_curr_level->SetInput(0, tcc_merge1);
		inc_curr_level->Cook();
		{
			FTccGeometryPtr Geo0 = inc_curr_level->GetGeoResult(0);
			FTccAttribPtr attr_curr_level = Geo0->AddDetailAttrib("curr_level", ETccAttribType::I);
			int32& _curr_level = attr_curr_level->GetData<int32>()[0];
			_curr_level += 1;
		}
	}
	SetGeoResult(UTcrTreeBranchSkeleton::output0, inc_curr_level->GetGeoResult(0));
}

