// Auto generated by UnrealTcc. 

#include "TcrTreeBigSubbranchesGrowth.h"
#include "TcrTreeSimpleLeaf.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeBigSubbranchesGrowth::UTcrTreeBigSubbranchesGrowth() 
{
}
FTccNodePtr UTcrTreeBigSubbranchesGrowth::CreateNode() 
{
	TSharedPtr<FTcrTreeBigSubbranchesGrowth> Node = MakeShared<FTcrTreeBigSubbranchesGrowth>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeBigSubbranchesGrowth::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeBigSubbranchesGrowth> Node = StaticCastSharedPtr<FTcrTreeBigSubbranchesGrowth>(InNode);
	Node->Gseed = Gseed;
	Node->Yaw = Yaw;
	Node->YawR = YawR;
	Node->Pitch = Pitch;
	Node->PitchR = PitchR;
	Node->Roll = Roll;
	Node->Yaw2 = Yaw2;
	Node->YawR2 = YawR2;
	Node->Pitch2 = Pitch2;
	Node->PitchR2 = PitchR2;
}

 FTcrTreeBigSubbranchesGrowth::FTcrTreeBigSubbranchesGrowth() 
{
	InitInputsCount(1);
	line = new FTccVex();
	line->InitMultiRefs(true); // RefCount = 3
	tcc_poly_frame1 = new FTccPolyFrame();
	tcc_poly_frame1->InitMultiRefs(false); // RefCount = 1
	scatter_branch = new FTccVex();
	scatter_branch->InitMultiRefs(false); // RefCount = 1
	tcc_copy_to_point2 = new FTccCopyToPoint();
	tcc_copy_to_point2->InitMultiRefs(true); // RefCount = 2
	tcc_merge2 = new FTccMerge();
	tcc_merge2->InitMultiRefs(false); // RefCount = 1
	tcc_poly_wire1 = new FTccPolyWire();
	tcc_poly_wire1->InitMultiRefs(false); // RefCount = 1
	tcr_tree_simple_leaf1 = new FTcrTreeSimpleLeaf();
	tcr_tree_simple_leaf1->InitMultiRefs(false); // RefCount = 1
	tcc_measure1 = new FTccMeasure();
	tcc_measure1->InitMultiRefs(false); // RefCount = 1
	foreach_begin1 = new FTccForBlock();
	foreach_begin1->InitMultiRefs(false); // RefCount = 1
	foreach_begin1->InitInputsCount(1);
		tcc_poly_frame2 = new FTccPolyFrame();
		tcc_poly_frame2->InitMultiRefs(false); // RefCount = 1
		scatter_leaves = new FTccVex();
		scatter_leaves->InitMultiRefs(false); // RefCount = 1
	tcc_instancer1 = new FTccInstancer();
	tcc_instancer1->InitMultiRefs(false); // RefCount = 1
	tcc_unpack1 = new FTccUnpack();
	tcc_unpack1->InitMultiRefs(false); // RefCount = 1
	tcc_merge1 = new FTccMerge();
	tcc_merge1->InitMultiRefs(false); // RefCount = 1
}
 FTcrTreeBigSubbranchesGrowth::~FTcrTreeBigSubbranchesGrowth() 
{
	delete line; 
	delete tcc_poly_frame1; 
	delete scatter_branch; 
	delete tcc_copy_to_point2; 
	delete tcc_merge2; 
	delete tcc_poly_wire1; 
	delete tcr_tree_simple_leaf1; 
	delete tcc_measure1; 
	delete foreach_begin1; 
		delete tcc_poly_frame2; 
		delete scatter_leaves; 
	delete tcc_instancer1; 
	delete tcc_unpack1; 
	delete tcc_merge1; 
}
void FTcrTreeBigSubbranchesGrowth::Cook() 
{
	{
		// Node: line
		FTccRampFloat _soft = ETccRampInterp::Linear;
		_soft.ResizeRampPoints(2);
		_soft.AddRampPoint(0.0000f, 0.4000f);
		_soft.AddRampPoint(1.0000f, 1.0000f);
		float _age = 0.719000f;
		int32 _segs = 4;
		float _up_force = 0.431000f;
		line->Cook();
		{
			FTccGeometryPtr Geo0 = line->GetGeoRef(0);
			const float age = _age;
			const int32 segs = _segs;
			const float age_step = age / segs;
			const FVector3f forward_dir = vex_normalize(vex_set(0, 1, 1));
			const FVector3f up_dir = vex_set(0, 1, 0);
			const float up_force = _up_force;
			TArray < FVector3f > poses;
			TArray < float > ages;
			vex_resize(poses, segs + 1);
			vex_resize(ages, segs + 1);
			FVector3f pos = vex_set(0, 0, 0);
			FVector3f dir = forward_dir;
			poses [ 0] = pos;
			ages [ 0] = 0.f;
			for(int i = 0;i < segs;++ i)
			{
			pos += dir * age_step;
			float f = up_force;
			f *= _soft.Lookup((float(i + 1) / segs));
			dir = vex_normalize(dir + up_dir * f);
			poses [ i + 1] = pos;
			ages [ i + 1] = age_step * (i + 1);
			}
			TArray < int32 > pts= vex_addpoints(Geo0, poses);
			vex_setpointsattrib(Geo0, "age", pts, ages);
			vex_addprim(Geo0, "polyline", pts);
		}
	}
	{
		// Node: tcc_poly_frame1
		tcc_poly_frame1->SetInput(0, line);
		tcc_poly_frame1->Tangentu = TEXT("dir");
		tcc_poly_frame1->Cook();
	}
	{
		// Node: scatter_branch
		scatter_branch->SetInput(0, nullptr);
		scatter_branch->SetInput(1, tcc_poly_frame1);
		float _start = 0.312000f;
		int32 _count = 6;
		int32 _mirror = 0;
		FVector2f _yaw = FVector2f(Yaw2.X, Yaw2.Y);
		float _yaw_r = float(YawR2);
		FVector2f _pitch = FVector2f(Pitch2.X, Pitch2.Y);
		float _pitch_r = float(PitchR2);
		float _roll = 0.000000f;
		FVector2f _scale = FVector2f(0.600000f, 0.100000f);
		float _scale_r = 0.000000f;
		scatter_branch->Cook();
		{
			FTccGeometryPtr Geo0 = scatter_branch->GetGeoRef(0);
			FTccGeometryConstPtr Geo1 = tcc_poly_frame1->GetConstGeoResult(0);
			const int32 seed = Gseed;
			const int32 count = _count;
			const int32 mirror = _mirror;
			const FVector2f yaw = vex_radians(_yaw);
			const float yaw_r = _yaw_r;
			const FVector2f pitch = vex_radians(_pitch);
			const float pitch_r = _pitch_r;
			const float roll = vex_radians(_roll);
			const FVector2f scale = _scale;
			const float scale_r = _scale_r;
			const float eps = 0.00001f;
			float start_percent = _start;
			TArray < int32 > parent_pts= vex_primpoints(Geo1, 0);
			int32 num_parent_pts = vex_len(parent_pts);
			int32 num_parent_segs = num_parent_pts - 1;
			float _age0 = vex_pointf(Geo1, "age", 0);
			float _age1 = vex_pointf(Geo1, "age", parent_pts [ num_parent_pts - 1]);
			float percent_step = (1.f - start_percent) / (count - 1 + eps);
			if(count == 1)
			{
			start_percent = 1.f;
			}
			int32 total_pts = count * ((mirror > 0)? 2 : 1);
			TArray < FVector3f > poses;
			TArray < FVector4f > rots;
			TArray < float > scales;
			vex_resize(poses, total_pts);
			vex_resize(rots, total_pts);
			vex_resize(scales, total_pts);
			int32 pt_index = 0;
			for(int i = 0;i < count;i ++)
			{
			float percent = start_percent + percent_step * i;
			int32 pt0 = (int)(num_parent_segs * percent);
			int32 pt1 = vex_min(pt0 + 1, num_parent_segs);
			float ratio = vex_clamp(percent * num_parent_segs - pt0, 0.f, 1.f);
			FVector3f pos0 = vex_pointp(Geo1, pt0);
			FVector3f pos1 = vex_pointp(Geo1, pt1);
			FVector3f dir0 = vex_pointv(Geo1, "dir", pt0);
			FVector3f dir1 = vex_pointv(Geo1, "dir", pt1);
			FVector3f pos = vex_lerp(pos0, pos1, ratio);
			FVector3f dir = vex_normalize(vex_lerp(dir0, dir1, ratio));
			float range_pos = 0.f;
			if(count > 1)
			range_pos = float(i) / (count - 1);
			float acos_v =  - dir.Z;// tcc_mark:replace=dir.Z / dir.Z
			FVector4f q0 = vex_quaternion(acos(acos_v), {1, 0, 0});
			float yawi = vex_lerp(yaw.X, yaw.Y, range_pos);
			float pitchi = vex_lerp(pitch.X, pitch.Y, range_pos);
			float si = vex_lerp(scale.X, scale.Y, range_pos);
			float yaw__ = yawi + vex_fit01(vex_rand(seed + i + 4),  - 1, 1) * yaw_r * (yaw.Y - yaw.X) * 0.5f;
			FVector4f qyaw = vex_quaternion(yaw__, dir);
			float pitch__ = pitchi + vex_fit01(vex_rand(seed + i + 5),  - 1, 1) * pitch_r * (pitch.Y - pitch.X) * 0.5f;
			FVector4f qpitch = vex_quaternion(pitch__, {1, 0, 0});
			float roll__ = roll * vex_fit01(vex_rand(seed + i + 6),  - 1, 1);
			FVector4f qroll = vex_quaternion(roll__, {0, 0, 1});
			FVector4f q = vex_qmultiply(qyaw, q0);
			q = vex_qmultiply(q, qpitch);
			q = vex_qmultiply(q, qroll);
			float s = si + vex_fit01(vex_rand(seed + i + 101),  - 1, 1) * scale_r * (scale.Y - scale.X) * 0.5f;
			    // int pt = addpoint(0, pos);
			    // setpointattrib(0, "orient", pt, q);
			    // setpointattrib(0, "pscale", pt, s);
			poses [ pt_index] = pos;
			rots [ pt_index] = q;
			scales [ pt_index] = s;
			++ pt_index;
			if(mirror)
			{
			yaw__ =  - yawi + vex_fit01(vex_rand(seed + i + 14),  - 1, 1) * yaw_r * (yaw.Y - yaw.X) * 0.5f;
			qyaw = vex_quaternion(yaw__, dir);
			pitch__ = pitchi + vex_fit01(vex_rand(seed + i + 15),  - 1, 1) * pitch_r * (pitch.Y - pitch.X) * 0.5f;
			qpitch = vex_quaternion(pitch__, {1, 0, 0});
			roll__ = roll * vex_fit01(vex_rand(seed + i + 16),  - 1, 1);
			qroll = vex_quaternion(roll__, {0, 0, 1});
			q = vex_qmultiply(qyaw, q0);
			q = vex_qmultiply(q, qpitch);
			q = vex_qmultiply(q, qroll);
			s = si + vex_fit01(vex_rand(seed + i + 102),  - 1, 1) * scale_r * (scale.Y - scale.X) * 0.5f;
			        
			        // pt = addpoint(0, pos);
			        // setpointattrib(0, "orient", pt, q);
			        // setpointattrib(0, "pscale", pt, s);
			poses [ pt_index] = pos;
			rots [ pt_index] = q;
			scales [ pt_index] = s;
			++ pt_index;
			}
			}
			TArray < int32 > pts= vex_addpoints(Geo0, poses);
			vex_setpointsattrib(Geo0, "orient", pts, rots);
			vex_setpointsattrib(Geo0, "pscale", pts, scales);
		}
	}
	{
		// Node: tcc_copy_to_point2
		tcc_copy_to_point2->SetInput(0, line);
		tcc_copy_to_point2->SetInput(1, scatter_branch);
		tcc_copy_to_point2->Cook();
	}
	{
		// Node: tcc_merge2
		tcc_merge2->SetInput(0, line);
		tcc_merge2->SetInput(1, tcc_copy_to_point2);
		tcc_merge2->Cook();
	}
	{
		// Node: tcc_poly_wire1
		tcc_poly_wire1->SetInput(0, tcc_merge2);
		tcc_poly_wire1->R = 0.010000f;
		tcc_poly_wire1->Divs = 7;
		tcc_poly_wire1->Cook();
	}
	{
		// Node: tcr_tree_simple_leaf1
		tcr_tree_simple_leaf1->Shape = ETccRampInterp::Linear;
		tcr_tree_simple_leaf1->Shape.ResizeRampPoints(7);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(0.0000f, 0.0885f);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(0.1035f, 0.7708f);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(0.3643f, 1.0000f);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(0.5442f, 1.0000f);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(0.7965f, 0.8125f);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(0.9337f, 0.1667f);
		tcr_tree_simple_leaf1->Shape.AddRampPoint(1.0000f, 0.0000f);
		tcr_tree_simple_leaf1->Size = FVector2f(0.150000f, 0.200000f);
		tcr_tree_simple_leaf1->Stem = 0.010000f;
		tcr_tree_simple_leaf1->Cook();
	}
	{
		// Node: tcc_measure1
		tcc_measure1->SetInput(0, tcc_copy_to_point2);
		tcc_measure1->Measure = UTccMeasure::Perimeter;
		tcc_measure1->Attribname = TEXT("len");
		tcc_measure1->Cook();
	}
	{
		// Node: foreach_begin1
		foreach_begin1->SetInput(0, tcc_measure1);
		foreach_begin1->Itermethod = UTccForBlock::ByPiecesOrPoints;
		foreach_begin1->Method = UTccForBlock::MergeEachIteration;
		foreach_begin1->Class = UTccForBlock::Primitives;
		foreach_begin1->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = foreach_begin1->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				FTccNode* block_input0 = new FTccNode();
				block_input0->SetGeoResult(0, foreach_begin1->GetGeometryPiece(piece));
				{
					// Node: tcc_poly_frame2
					tcc_poly_frame2->SetInput(0, block_input0);
					tcc_poly_frame2->Tangentu = TEXT("dir");
					tcc_poly_frame2->Cook();
				}
				
				{
					// Node: scatter_leaves
					scatter_leaves->SetInput(0, nullptr);
					scatter_leaves->SetInput(1, tcc_poly_frame2);
					float _start = 0.498000f;
					float _dis = 0.100000f;
					int32 _mirror = 1;
					FVector2f _yaw = FVector2f(Yaw.X, Yaw.Y);
					float _yaw_r = float(YawR);
					FVector2f _pitch = FVector2f(Pitch.X, Pitch.Y);
					float _pitch_r = float(PitchR);
					float _roll = float(Roll);
					FVector2f _scale = FVector2f(0.500000f, 0.700000f);
					float _scale_r = 0.112000f;
					scatter_leaves->Cook();
					{
						FTccGeometryPtr Geo0 = scatter_leaves->GetGeoRef(0);
						FTccGeometryConstPtr Geo1 = tcc_poly_frame2->GetConstGeoResult(0);
						const int32 seed = Gseed;
						const float dis = _dis;
						const float l = vex_primf(Geo1, "len", 0);
						const int32 count = vex_max(1, (int)(l / dis + 0.5f));
						const int32 mirror = _mirror;
						const FVector2f yaw = vex_radians(_yaw);
						const float yaw_r = _yaw_r;
						const FVector2f pitch = vex_radians(_pitch);
						const float pitch_r = _pitch_r;
						const float roll = vex_radians(_roll);
						const FVector2f scale = _scale;
						const float scale_r = _scale_r;
						const float eps = 0.00001f;
						float start_percent = _start;
						//const int count = chi("count");
						TArray < int32 > parent_pts= vex_primpoints(Geo1, 0);
						int32 num_parent_pts = vex_len(parent_pts);
						int32 num_parent_segs = num_parent_pts - 1;
						float _age0 = vex_pointf(Geo1, "age", 0);
						float _age1 = vex_pointf(Geo1, "age", parent_pts [ num_parent_pts - 1]);
						float percent_step = (1.f - start_percent) / (count - 1 + eps);
						if(count == 1)
						{
						start_percent = 1.f;
						}
						int32 total_pts = count * ((mirror > 0)? 2 : 1);
						TArray < FVector3f > poses;
						TArray < FVector4f > rots;
						TArray < float > scales;
						vex_resize(poses, total_pts);
						vex_resize(rots, total_pts);
						vex_resize(scales, total_pts);
						int32 pt_index = 0;
						for(int i = 0;i < count;i ++)
						{
						float percent = start_percent + percent_step * i;
						int32 pt0 = (int)(num_parent_segs * percent);
						int32 pt1 = vex_min(pt0 + 1, num_parent_segs);
						float ratio = vex_clamp(percent * num_parent_segs - pt0, 0.f, 1.f);
						FVector3f pos0 = vex_pointp(Geo1, pt0);
						FVector3f pos1 = vex_pointp(Geo1, pt1);
						FVector3f dir0 = vex_pointv(Geo1, "dir", pt0);
						FVector3f dir1 = vex_pointv(Geo1, "dir", pt1);
						FVector3f pos = vex_lerp(pos0, pos1, ratio);
						FVector3f dir = vex_normalize(vex_lerp(dir0, dir1, ratio));
						float range_pos = 0.f;
						if(count > 1)
						range_pos = float(i) / (count - 1);
						float acos_v =  - dir.Z;// tcc_mark:replace=dir.Z / dir.Z
						FVector4f q0 = vex_quaternion(acos(acos_v), {1, 0, 0});
						float yawi = vex_lerp(yaw.X, yaw.Y, range_pos);
						float pitchi = vex_lerp(pitch.X, pitch.Y, range_pos);
						float si = vex_lerp(scale.X, scale.Y, range_pos);
						float yaw__ = yawi + vex_fit01(vex_rand(seed + i + 4),  - 1, 1) * yaw_r * (yaw.Y - yaw.X) * 0.5f;
						FVector4f qyaw = vex_quaternion(yaw__, dir);
						float pitch__ = pitchi + vex_fit01(vex_rand(seed + i + 5),  - 1, 1) * pitch_r * (pitch.Y - pitch.X) * 0.5f;
						FVector4f qpitch = vex_quaternion(pitch__, {1, 0, 0});
						float roll__ = roll * vex_fit01(vex_rand(seed + i + 6),  - 1, 1);
						FVector4f qroll = vex_quaternion(roll__, {0, 0, 1});
						FVector4f q = vex_qmultiply(qyaw, q0);
						q = vex_qmultiply(q, qpitch);
						q = vex_qmultiply(q, qroll);
						float s = si + vex_fit01(vex_rand(seed + i + 101),  - 1, 1) * scale_r * (scale.Y - scale.X) * 0.5f;
						    // int pt = addpoint(0, pos);
						    // setpointattrib(0, "orient", pt, q);
						    // setpointattrib(0, "pscale", pt, s);
						poses [ pt_index] = pos;
						rots [ pt_index] = q;
						scales [ pt_index] = s;
						++ pt_index;
						if(mirror)
						{
						yaw__ =  - yawi + vex_fit01(vex_rand(seed + i + 14),  - 1, 1) * yaw_r * (yaw.Y - yaw.X) * 0.5f;
						qyaw = vex_quaternion(yaw__, dir);
						pitch__ = pitchi + vex_fit01(vex_rand(seed + i + 15),  - 1, 1) * pitch_r * (pitch.Y - pitch.X) * 0.5f;
						qpitch = vex_quaternion(pitch__, {1, 0, 0});
						roll__ = roll * vex_fit01(vex_rand(seed + i + 16),  - 1, 1);
						qroll = vex_quaternion(roll__, {0, 0, 1});
						q = vex_qmultiply(qyaw, q0);
						q = vex_qmultiply(q, qpitch);
						q = vex_qmultiply(q, qroll);
						s = si + vex_fit01(vex_rand(seed + i + 102),  - 1, 1) * scale_r * (scale.Y - scale.X) * 0.5f;
						        
						        // pt = addpoint(0, pos);
						        // setpointattrib(0, "orient", pt, q);
						        // setpointattrib(0, "pscale", pt, s);
						poses [ pt_index] = pos;
						rots [ pt_index] = q;
						scales [ pt_index] = s;
						++ pt_index;
						}
						}
						TArray < int32 > pts= vex_addpoints(Geo0, poses);
						vex_setpointsattrib(Geo0, "orient", pts, rots);
						vex_setpointsattrib(Geo0, "pscale", pts, scales);
					}
				}
				
				foreach_begin1->SetPieceResult(piece, scatter_leaves->GetGeoResult(0));
				delete block_input0;
			}
			foreach_begin1->MergeResult();
		}
	}
	{
		// Node: tcc_instancer1
		tcc_instancer1->SetInput(0, tcr_tree_simple_leaf1);
		tcc_instancer1->SetInput(1, foreach_begin1);
		tcc_instancer1->Idattrib = TEXT("variant");
		tcc_instancer1->Cook();
	}
	{
		// Node: tcc_unpack1
		tcc_unpack1->SetInput(0, tcc_instancer1);
		tcc_unpack1->Cook();
	}
	{
		// Node: tcc_merge1
		tcc_merge1->SetInput(0, tcc_poly_wire1);
		tcc_merge1->SetInput(1, tcc_unpack1);
		tcc_merge1->Cook();
	}
	SetGeoResult(UTcrTreeBigSubbranchesGrowth::output0, tcc_merge1->GetGeoResult(0));
}

