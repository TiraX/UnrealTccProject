// Auto generated by UnrealTcc. 

#include "TcrMushroomStem.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrMushroomStem::UTcrMushroomStem() 
{
	RadiusShape.ResizeRampPoints(3);
	RadiusShape.AddRampPoint(0.0000f, 0.6458f);
	RadiusShape.AddRampPoint(0.1403f, 1.0000f);
	RadiusShape.AddRampPoint(1.0000f, 0.5000f);
	CurlS.ResizeRampPoints(2);
	CurlS.AddRampPoint(0.0000f, 1.0000f);
	CurlS.AddRampPoint(1.0000f, 0.0000f);
}
FTccNodePtr UTcrMushroomStem::CreateNode() 
{
	TSharedPtr<FTcrMushroomStem> Node = MakeShared<FTcrMushroomStem>();
	SyncParams(Node);
	return Node;
}
void UTcrMushroomStem::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrMushroomStem> Node = StaticCastSharedPtr<FTcrMushroomStem>(InNode);
	Node->RadiusShape = RadiusShape;
	Node->CurlS = CurlS;
	Node->Gseed = Gseed;
	Node->Ori = Ori;
	Node->H = H;
	Node->SegsV = SegsV;
	Node->StemR = StemR;
	Node->Yaw = Yaw;
	Node->Pitch0 = Pitch0;
	Node->Pitch1 = Pitch1;
	Node->PitchRange = PitchRange;
	Node->Amp = Amp;
	Node->Freq = Freq;
}

 FTcrMushroomStem::FTcrMushroomStem() 
{
	InitInputsCount(0);
	stem_line = new FTccVex();
	stem_line->InitMultiRefs(false); // RefCount = 1
	apply_radius = new FTccVex();
	apply_radius->InitMultiRefs(false); // RefCount = 1
	use_curl = new FTccSwitch();
	use_curl->InitMultiRefs(true); // RefCount = 2
		apply_curl = new FTccVex();
		apply_curl->InitMultiRefs(false); // RefCount = 1
	tcc_poly_wire1 = new FTccPolyWire();
	tcc_poly_wire1->InitMultiRefs(false); // RefCount = 1
	attrib_for_umbrella = new FTccVex();
	attrib_for_umbrella->InitMultiRefs(false); // RefCount = 1
	RadiusShape.ResizeRampPoints(3);
	RadiusShape.AddRampPoint(0.0000f, 0.6458f);
	RadiusShape.AddRampPoint(0.1403f, 1.0000f);
	RadiusShape.AddRampPoint(1.0000f, 0.5000f);
	CurlS.ResizeRampPoints(2);
	CurlS.AddRampPoint(0.0000f, 1.0000f);
	CurlS.AddRampPoint(1.0000f, 0.0000f);
}
 FTcrMushroomStem::~FTcrMushroomStem() 
{
	delete stem_line; 
	delete apply_radius; 
	delete use_curl; 
		delete apply_curl; 
	delete tcc_poly_wire1; 
	delete attrib_for_umbrella; 
}
void FTcrMushroomStem::Cook() 
{
	{
		// Node: stem_line
		stem_line->Cook();
		{
			FTccGeometryPtr Geo0 = stem_line->GetGeoRef(0);
			const float height = H;
			const float __yaw = vex_radians(Yaw);
			const float ph0 = vex_radians(Pitch0);
			const float ph1 = vex_radians(Pitch1);
			const FVector2f ph_range = PitchRange;
			const FVector3f origin = Ori;
			const int32 num_pts = SegsV + 1;
			const float u_step = 1.f / (num_pts - 1);
			const float h_step = height * u_step;
			float x0 = sin(__yaw);
			float z0 = cos(__yaw);
			TArray < FVector3f > poses;
			TArray < float > u_coords;
			vex_resize(poses, num_pts);
			vex_resize(u_coords, num_pts);
			FVector3f pos = origin;
			poses [ 0] = pos;
			u_coords [ 0] = 0.f;
			for(int p = 1;p < num_pts;p ++)
			{
			float u = u_step * p;
			float percent = vex_fitto01(u, ph_range.X, ph_range.Y);
			float local_pitch = vex_lerp(ph0, ph1, percent);
			float r_h = cos(local_pitch);
			FVector3f dir = vex_set(r_h * x0, sin(local_pitch), r_h * z0);
			pos += dir * h_step;
			poses [ p] = pos;
			u_coords [ p] = u;
			}
			TArray < int32 > pts= vex_addpoints(Geo0, poses);
			vex_setpointsattrib(Geo0, "curveu", pts, u_coords);
			vex_addprim(Geo0, "polyline", pts);
		}
	}
	{
		// Node: apply_radius
		apply_radius->SetInput(0, stem_line);
		apply_radius->Cook();
		{
			FTccGeometryPtr Geo0 = apply_radius->GetGeoRef(0);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", ETccAttribType::F);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
			const float r = StemR * 2.f;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _radius = attr_radius->GetData<float>()[i];
				float& _curveu = attr_curveu->GetData<float>()[i];
				_radius = r * RadiusShape.Lookup(_curveu);
			}
		}
	}
	{
		// Node: use_curl
		use_curl->SetInput(0, apply_radius);
		use_curl->Input = int32(Amp > 0);
		use_curl->NumCases = 2;
		use_curl->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = use_curl->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: apply_curl
					apply_curl->SetInput(0, apply_radius);
					apply_curl->Cook();
					{
						FTccGeometryPtr Geo0 = apply_curl->GetGeoRef(0);
						const int32 seed = Gseed + 3;
						const float curl_amp = Amp;
						const float curl_freq = Freq;
						const int32 num_pts = vex_npoints(Geo0);
						const float inv_num_pts = 1.f / num_pts;
						FVector3f acc = vex_set(0, 0, 0);
						for(int p = 1;p < num_pts;++ p)
						{
						FVector3f pos = vex_pointp(Geo0, p);
						FVector3f pseed = pos * curl_freq + vex_set(seed, seed, seed);
						FVector3f n = vex_curlnoise2d(pseed) * curl_amp;
						float u = vex_pointf(Geo0, "curveu", p);
						FVector3f offset = vex_set(n.X, 0, n.Y) * CurlS.Lookup(u) * inv_num_pts;
						acc += offset;
						    
						pos += acc;
						vex_setpointattrib(Geo0, "P", p, pos);
						}
					}
				}
				
				SwitchResult = apply_curl->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		use_curl->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: tcc_poly_wire1
		tcc_poly_wire1->SetInput(0, use_curl);
		tcc_poly_wire1->EnableRadiusAttrib = 1;
		tcc_poly_wire1->RAttrib = TEXT("radius");
		tcc_poly_wire1->Divs = 10;
		tcc_poly_wire1->Cook();
	}
	{
		// Node: attrib_for_umbrella
		attrib_for_umbrella->SetInput(0, tcc_poly_wire1);
		attrib_for_umbrella->SetInput(1, use_curl);
		attrib_for_umbrella->Cook();
		{
			FTccGeometryPtr Geo0 = attrib_for_umbrella->GetGeoRef(0);
			FTccGeometryConstPtr Geo1 = use_curl->GetConstGeoResult(0);
			FTccAttribPtr attr_end_point = Geo0->AddDetailAttrib("end_point", ETccAttribType::F3);
			FTccAttribPtr attr_end_dir = Geo0->AddDetailAttrib("end_dir", ETccAttribType::F3);
			FTccAttribPtr attr_stem_r = Geo0->AddDetailAttrib("stem_r", ETccAttribType::F);
			const int32 num_pts = vex_npoints(Geo1);
			FVector3f& _end_point = attr_end_point->GetData<FVector3f>()[0];
			FVector3f& _end_dir = attr_end_dir->GetData<FVector3f>()[0];
			float& _stem_r = attr_stem_r->GetData<float>()[0];
			FVector3f p1 = vex_pointp(Geo1, num_pts - 1);
			FVector3f p0 = vex_pointp(Geo1, num_pts - 2);
			_end_point = p1;
			_end_dir = vex_normalize(p1 - p0);
			_stem_r = StemR;
		}
	}
	SetGeoResult(UTcrMushroomStem::output0, attrib_for_umbrella->GetGeoResult(0));
}

