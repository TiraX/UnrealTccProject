// Auto generated by UnrealTcc. 

#include "TcrTreeLeafScatterVariation.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeLeafScatterVariation::UTcrTreeLeafScatterVariation() 
{
	ScaleRamp.ResizeRampPoints(3);
	ScaleRamp.AddRampPoint(0.0000f, 0.0000f);
	ScaleRamp.AddRampPoint(0.2510f, 1.0000f);
	ScaleRamp.AddRampPoint(1.0000f, 0.0000f);
}
FTccNodePtr UTcrTreeLeafScatterVariation::CreateNode() 
{
	TSharedPtr<FTcrTreeLeafScatterVariation> Node = MakeShared<FTcrTreeLeafScatterVariation>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeLeafScatterVariation::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeLeafScatterVariation> Node = StaticCastSharedPtr<FTcrTreeLeafScatterVariation>(InNode);
	Node->ScaleRamp = ScaleRamp;
	Node->BranchSeed = BranchSeed;
	Node->Method = Method;
	Node->Npts = Npts;
	Node->Distance = Distance;
	Node->GrowMin = GrowMin;
	Node->GrowMax = GrowMax;
	Node->Mirror = Mirror;
	Node->YawRange = YawRange;
	Node->Pitch = Pitch;
	Node->PitchRand = PitchRand;
	Node->Roll = Roll;
	Node->Scale = Scale;
	Node->Prune = Prune;
	Node->EnableScaleCurve = EnableScaleCurve;
}

 FTcrTreeLeafScatterVariation::FTcrTreeLeafScatterVariation() 
{
	InitInputsCount(3);
	remove_other_levels = new FTccBlastByFeature();
	remove_other_levels->InitMultiRefs(false); // RefCount = 1
	remove_under_min = new FTccBlastByFeature();
	remove_under_min->InitMultiRefs(false); // RefCount = 1
	remove_above_max = new FTccBlastByFeature();
	remove_above_max->InitMultiRefs(false); // RefCount = 1
	tcc_measure1 = new FTccMeasure();
	tcc_measure1->InitMultiRefs(false); // RefCount = 1
	remove_0_len = new FTccBlastByFeature();
	remove_0_len->InitMultiRefs(false); // RefCount = 1
	branch_dir = new FTccPolyFrame();
	branch_dir->InitMultiRefs(false); // RefCount = 1
	tcc_attrib_promote1 = new FTccAttribPromote();
	tcc_attrib_promote1->InitMultiRefs(true); // RefCount = 999
	foreach_branch2 = new FTccForBlock();
	foreach_branch2->InitMultiRefs(false); // RefCount = 1
	foreach_branch2->InitInputsCount(3);
		calc_count_and_seed = new FTccVex();
		calc_count_and_seed->InitMultiRefs(false); // RefCount = 1
		tcc_dithered_scatter1 = new FTccDitheredScatter();
		tcc_dithered_scatter1->InitMultiRefs(false); // RefCount = 1
		tcc_sort3 = new FTccSort();
		tcc_sort3->InitMultiRefs(false); // RefCount = 1
		min_max_u2 = new FTccAttribPromote();
		min_max_u2->InitMultiRefs(true); // RefCount = 2
		enable_mirror = new FTccSwitch();
		enable_mirror->InitMultiRefs(false); // RefCount = 1
			default_dir = new FTccVex();
			default_dir->InitMultiRefs(false); // RefCount = 1
			mirror_dir_pos = new FTccVex();
			mirror_dir_pos->InitMultiRefs(false); // RefCount = 1
			mirror_dir_neg = new FTccVex();
			mirror_dir_neg->InitMultiRefs(false); // RefCount = 1
			tcc_merge3 = new FTccMerge();
			tcc_merge3->InitMultiRefs(false); // RefCount = 1
		calc_rotation2 = new FTccVex();
		calc_rotation2->InitMultiRefs(false); // RefCount = 1
		tcc_attrib_delete2 = new FTccAttribDelete();
		tcc_attrib_delete2->InitMultiRefs(false); // RefCount = 1
		apply_scale = new FTccVex();
		apply_scale->InitMultiRefs(false); // RefCount = 1
		add_instance_id = new FTccVex();
		add_instance_id->InitMultiRefs(false); // RefCount = 1
		tcc_instancer2 = new FTccInstancer();
		tcc_instancer2->InitMultiRefs(false); // RefCount = 1
	ScaleRamp.ResizeRampPoints(3);
	ScaleRamp.AddRampPoint(0.0000f, 0.0000f);
	ScaleRamp.AddRampPoint(0.2510f, 1.0000f);
	ScaleRamp.AddRampPoint(1.0000f, 0.0000f);
}
 FTcrTreeLeafScatterVariation::~FTcrTreeLeafScatterVariation() 
{
	delete remove_other_levels; 
	delete remove_under_min; 
	delete remove_above_max; 
	delete tcc_measure1; 
	delete remove_0_len; 
	delete branch_dir; 
	delete tcc_attrib_promote1; 
	delete foreach_branch2; 
		delete calc_count_and_seed; 
		delete tcc_dithered_scatter1; 
		delete tcc_sort3; 
		delete min_max_u2; 
		delete enable_mirror; 
			delete default_dir; 
			delete mirror_dir_pos; 
			delete mirror_dir_neg; 
			delete tcc_merge3; 
		delete calc_rotation2; 
		delete tcc_attrib_delete2; 
		delete apply_scale; 
		delete add_instance_id; 
		delete tcc_instancer2; 
}
void FTcrTreeLeafScatterVariation::Cook() 
{
	{
		// Node: remove_other_levels
		remove_other_levels->SetInput(0, GetInput(0));
		FTccGeometryConstPtr Geo0 = remove_other_levels->GetInput(0)->GetConstGeoResult(0);
		remove_other_levels->ByAttrib = 1;
		remove_other_levels->Attrib = TEXT("level");
		remove_other_levels->Op = UTccBlastByFeature::NotEqual;
		remove_other_levels->Value = float(hs_detail(Geo0, "curr_level", 0));
		remove_other_levels->Cook();
	}
	{
		// Node: remove_under_min
		remove_under_min->SetInput(0, remove_other_levels);
		remove_under_min->Grouptype = UTccBlastByFeature::Points;
		remove_under_min->ByAttrib = 1;
		remove_under_min->Attrib = TEXT("curveu");
		remove_under_min->Op = UTccBlastByFeature::Less;
		remove_under_min->Value = float(GrowMin);
		remove_under_min->Cook();
	}
	{
		// Node: remove_above_max
		remove_above_max->SetInput(0, remove_under_min);
		remove_above_max->Grouptype = UTccBlastByFeature::Points;
		remove_above_max->ByAttrib = 1;
		remove_above_max->Attrib = TEXT("curveu");
		remove_above_max->Op = UTccBlastByFeature::Greater;
		remove_above_max->Value = float(GrowMax);
		remove_above_max->Cook();
	}
	{
		// Node: tcc_measure1
		tcc_measure1->SetInput(0, remove_above_max);
		tcc_measure1->Measure = UTccMeasure::Perimeter;
		tcc_measure1->Attribname = TEXT("length");
		tcc_measure1->Cook();
	}
	{
		// Node: remove_0_len
		remove_0_len->SetInput(0, tcc_measure1);
		remove_0_len->ByAttrib = 1;
		remove_0_len->Attrib = TEXT("length");
		remove_0_len->Cook();
	}
	{
		// Node: branch_dir
		branch_dir->SetInput(0, remove_0_len);
		branch_dir->Tangentu = TEXT("branch_dir");
		branch_dir->Cook();
	}
	{
		// Node: tcc_attrib_promote1
		tcc_attrib_promote1->SetInput(0, GetInput(1));
		tcc_attrib_promote1->Inname = TEXT("instance_id");
		tcc_attrib_promote1->Inclass = UTccAttribPromote::PackedGeos;
		tcc_attrib_promote1->Outclass = UTccAttribPromote::DetailOnlyOnce;
		tcc_attrib_promote1->DoMax = 1;
		tcc_attrib_promote1->Cook();
	}
	{
		// Node: foreach_branch2
		foreach_branch2->SetInput(0, branch_dir);
		foreach_branch2->SetInput(1, tcc_attrib_promote1);
		foreach_branch2->SetInput(2, GetInput(2));
		foreach_branch2->Itermethod = UTccForBlock::ByPiecesOrPoints;
		foreach_branch2->Method = UTccForBlock::MergeEachIteration;
		foreach_branch2->Class = UTccForBlock::Primitives;
		foreach_branch2->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = foreach_branch2->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				FTccNode* block_input0 = new FTccNode();
				block_input0->SetGeoResult(0, foreach_branch2->GetGeometryPiece(piece));
				FTccNode* block_input1 = tcc_attrib_promote1;
				FTccNode* block_input2 = GetInput(2);
				{
					// Node: calc_count_and_seed
					calc_count_and_seed->SetInput(0, block_input0);
					calc_count_and_seed->SetInput(1, nullptr);
					calc_count_and_seed->Cook();
					{
						FTccGeometryPtr Geo0 = calc_count_and_seed->GetGeoResult(0);
						FTccAttribPtr attr_total_count = Geo0->AddDetailAttrib("total_count", ETccAttribType::I);
						FTccAttribPtr attr_seed = Geo0->AddDetailAttrib("seed", ETccAttribType::I);
						const int32 method = Method;
						const int32 npts = Npts;
						const float distance = Distance;
						const int32 bseed = BranchSeed;
						int32& _total_count = attr_total_count->GetData<int32>()[0];
						int32& _seed = attr_seed->GetData<int32>()[0];
						int32 count = 0;
						if(method == 1)
						{
						    // by distance
						float l = vex_primf(Geo0, "length", 0);
						count = (int)(l / distance + 0.5f);
						}
						else
						{
						    // by count
						count = npts;
						}
						_total_count = count;
						int32 iter = _iteration;
						_seed = bseed + iter * 4;
					}
				}
				
				{
					// Node: tcc_dithered_scatter1
					tcc_dithered_scatter1->SetInput(0, calc_count_and_seed);
					FTccGeometryConstPtr Geo0 = tcc_dithered_scatter1->GetInput(0)->GetConstGeoResult(0);
					tcc_dithered_scatter1->Npts = int32(hs_detail(Geo0, "total_count", 0));
					tcc_dithered_scatter1->ScatterSeed = int32(hs_detail(Geo0, "seed", 0));
					tcc_dithered_scatter1->Jitter = 0.193000f;
					tcc_dithered_scatter1->Cook();
				}
				
				{
					// Node: tcc_sort3
					tcc_sort3->SetInput(0, tcc_dithered_scatter1);
					tcc_sort3->Ptsort = UTccSort::ByAttribute;
					tcc_sort3->Pointattrib = TEXT("curveu");
					tcc_sort3->Cook();
				}
				
				{
					// Node: min_max_u2
					min_max_u2->SetInput(0, tcc_sort3);
					min_max_u2->Inname = TEXT("curveu");
					min_max_u2->Outclass = UTccAttribPromote::DetailOnlyOnce;
					min_max_u2->DoMax = 1;
					min_max_u2->DoMin = 1;
					min_max_u2->Cook();
				}
				
				{
					// Node: enable_mirror
					enable_mirror->SetInput(0, min_max_u2);
					enable_mirror->Input = int32(Mirror);
					enable_mirror->NumCases = 2;
					enable_mirror->Cook();
					FTccGeometryPtr SwitchResult = nullptr;
					const int32 Selection = enable_mirror->Input;
					switch (Selection)
					{
						case 0:
						{
							{
								// Node: default_dir
								default_dir->SetInput(0, min_max_u2);
								default_dir->Cook();
								{
									FTccGeometryPtr Geo0 = default_dir->GetGeoResult(0);
									FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", ETccAttribType::F);
									const int32 _numpt = Geo0->GetNumPoints();
									for(int32 i = 0; i < _numpt; i++)
									{
										const int32 _ptnum = i;
										float& _dir = attr_dir->GetData<float>()[i];
										_dir = 1.0f;
									}
								}
							}
							
							
							
							
							SwitchResult = default_dir->GetGeoResult(0);
						}
						break;
						case 1:
						{
							
							{
								// Node: mirror_dir_pos
								mirror_dir_pos->SetInput(0, min_max_u2);
								mirror_dir_pos->Cook();
								{
									FTccGeometryPtr Geo0 = mirror_dir_pos->GetGeoResult(0);
									FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", ETccAttribType::F);
									const int32 _numpt = Geo0->GetNumPoints();
									for(int32 i = 0; i < _numpt; i++)
									{
										const int32 _ptnum = i;
										float& _dir = attr_dir->GetData<float>()[i];
										_dir = 1.0f;
									}
								}
							}
							
							{
								// Node: mirror_dir_neg
								mirror_dir_neg->SetInput(0, min_max_u2);
								mirror_dir_neg->Cook();
								{
									FTccGeometryPtr Geo0 = mirror_dir_neg->GetGeoResult(0);
									FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", ETccAttribType::F);
									const int32 _numpt = Geo0->GetNumPoints();
									for(int32 i = 0; i < _numpt; i++)
									{
										const int32 _ptnum = i;
										float& _dir = attr_dir->GetData<float>()[i];
										_dir =  - 1.0f;
									}
								}
							}
							
							{
								// Node: tcc_merge3
								tcc_merge3->SetInput(0, mirror_dir_pos);
								tcc_merge3->SetInput(1, mirror_dir_neg);
								tcc_merge3->Cook();
							}
							
							SwitchResult = tcc_merge3->GetGeoResult(0);
						}
						break;
						default:
						{
							checkNoEntry();
						}
						break;
					}
					enable_mirror->SetValidGeoResult(0, SwitchResult);
				}
				
				{
					// Node: calc_rotation2
					calc_rotation2->SetInput(0, enable_mirror);
					calc_rotation2->SetInput(1, nullptr);
					calc_rotation2->Cook();
					{
						FTccGeometryPtr Geo0 = calc_rotation2->GetGeoResult(0);
						FTccAttribPtr attr_branch_dir = Geo0->AddPointAttrib("branch_dir", ETccAttribType::F3);
						FTccAttribPtr attr_dir = Geo0->AddPointAttrib("dir", ETccAttribType::F);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
						const int32 gseed = BranchSeed;
						const int32 iter = _iteration;
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const FVector3f up = vex_set(0, 1, 0);
						const FVector2f yaw_range = vex_radians(YawRange);
						const float pitch = vex_radians(Pitch);
						const float pitch_rand = vex_radians(PitchRand);
						const float roll = vex_radians(Roll);
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _branch_dir = attr_branch_dir->GetData<FVector3f>()[i];
							float& _dir = attr_dir->GetData<float>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							FVector3f sub_branch_dir =  - _branch_dir;
							// YAW
							FVector3f n = vex_normalize(vex_cross(sub_branch_dir, up)) * _dir;
							FVector3f yaw_axis = vex_normalize(vex_cross(n, sub_branch_dir));
							float yaw = vex_fit(_curveu, min_u, max_u, yaw_range.X, yaw_range.Y);
							FVector4f qyaw = vex_quaternion(yaw, yaw_axis);
							n = vex_qrotate(qyaw, n);
							// PITCH
							FVector3f pitch_axis = sub_branch_dir;// vex_cross(yaw_axis, n);
							float pitch_r = vex_fit01(vex_rand(_ptnum * 1.45f + iter + 21),  - pitch_rand, pitch_rand);
							float pitch_result = (pitch + pitch_r) * _dir;
							FVector4f qpitch = vex_quaternion(pitch_result, pitch_axis);
							n = vex_normalize(vex_qrotate(qpitch, n));
							// ROLL
							FVector4f qroll = vex_quaternion(roll, n);
							FVector3f new_up = vex_qrotate(qroll, up);
							// Convert to orient
							FMatrix44f m3 = vex_maketransform(n, new_up);
							_orient = vex_quaternion(m3);
						}
					}
				}
				
				{
					// Node: tcc_attrib_delete2
					tcc_attrib_delete2->SetInput(0, calc_rotation2);
					tcc_attrib_delete2->Ptdel = TEXT("dir branch_dir");
					tcc_attrib_delete2->Dtldel = TEXT("max_curveu min_curveu");
					tcc_attrib_delete2->Cook();
				}
				
				{
					// Node: apply_scale
					apply_scale->SetInput(0, tcc_attrib_delete2);
					apply_scale->SetInput(1, nullptr);
					apply_scale->Cook();
					{
						FTccGeometryPtr Geo0 = apply_scale->GetGeoResult(0);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", ETccAttribType::F);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						const int32 iter = _iteration;
						const FVector2f s = Scale;
						const int32 along_curve = EnableScaleCurve;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _pscale = attr_pscale->GetData<float>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							_pscale = vex_fit01(vex_rand((_ptnum + 2.4f) * iter), s.X, s.Y);
							if(along_curve > 0)
							{
							_pscale *= ScaleRamp.Lookup(_curveu);
							}
						}
					}
				}
				
				{
					// Node: add_instance_id
					add_instance_id->SetInput(0, apply_scale);
					add_instance_id->SetInput(1, nullptr);
					add_instance_id->SetInput(2, block_input1);
					add_instance_id->SetInput(3, block_input2);
					add_instance_id->Cook();
					{
						FTccGeometryPtr Geo0 = add_instance_id->GetGeoResult(0);
						FTccGeometryConstPtr Geo2 = block_input1->GetConstGeoResult(0);
						FTccGeometryConstPtr Geo3 = block_input2->GetConstGeoResult(0);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", ETccAttribType::F);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
						FTccAttribPtr attr_instance_id = Geo0->AddPointAttrib("instance_id", ETccAttribType::I);
						const int32 max_instance_id = vex_detaili(Geo2, "max_instance_id");
						const int32 iter = _iteration;
						const int32 prune = Prune;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _pscale = attr_pscale->GetData<float>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							int32& _instance_id = attr_instance_id->GetData<int32>()[i];
							float r = vex_rand(iter * _ptnum * 2.7f + 3 + _ptnum);
							int32 selection = 0;
							if(prune == 0)
							{
							selection = (int)vex_fit01(r, 0, max_instance_id + 0.999f);
							}
							else
							{
							FVector3f f = vex_set(0, 0, _pscale);
							FVector4f q = _orient;
							f = vex_qrotate(q, f);
							    // hard code the range should select
							if(vex_volumesample(Geo3, "surface", _P + f * 3.0f)> 0)
							selection = r < 0.5f ? 0 : 1;
							else if(vex_volumesample(Geo3, "surface", _P + f * 6.0f)> 0)
							selection = r < 0.5f ? 2 : 3;
							else
							selection = r < 0.5f ? 4 : 5;
							}
							_instance_id = selection;
						}
					}
				}
				
				{
					// Node: tcc_instancer2
					tcc_instancer2->SetInput(0, block_input1);
					tcc_instancer2->SetInput(1, add_instance_id);
					tcc_instancer2->Useidattrib = 1;
					tcc_instancer2->Idattrib = TEXT("instance_id");
					tcc_instancer2->Cook();
				}
				
				foreach_branch2->SetPieceResult(piece, tcc_instancer2->GetGeoResult(0));
				delete block_input0;
			}
			foreach_branch2->MergeResult();
		}
	}
	SetGeoResult(UTcrTreeLeafScatterVariation::output0, foreach_branch2->GetGeoResult(0));
}

