// Auto generated by UnrealTcc. 

#include "TcrScatterOnBranches.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrScatterOnBranches::UTcrScatterOnBranches() 
{
}
FTccNodePtr UTcrScatterOnBranches::CreateNode() 
{
	TSharedPtr<FTcrScatterOnBranches> Node = MakeShared<FTcrScatterOnBranches>();
	SyncParams(Node);
	return Node;
}
void UTcrScatterOnBranches::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrScatterOnBranches> Node = StaticCastSharedPtr<FTcrScatterOnBranches>(InNode);
	Node->Gseed = Gseed;
	Node->Range = Range;
	Node->ScaleMin = ScaleMin;
	Node->ScaleMax = ScaleMax;
}

 FTcrScatterOnBranches::FTcrScatterOnBranches() 
{
	InitInputsCount(1);
	remove_attr_radius = new FTccAttribDelete();
	remove_attr_radius->InitMultiRefs(false); // RefCount = 1
	keep_level_1_lines_only = new FTccBlastByFeature();
	keep_level_1_lines_only->InitMultiRefs(false); // RefCount = 1
	tangentu = new FTccPolyFrame();
	tangentu->InitMultiRefs(false); // RefCount = 1
	remap_scatter_range = new FTccVex();
	remap_scatter_range->InitMultiRefs(false); // RefCount = 1
	foreach_begin1 = new FTccForBlock();
	foreach_begin1->InitMultiRefs(false); // RefCount = 1
	foreach_begin1->InitInputsCount(1);
		tcc_vex1 = new FTccVex();
		tcc_vex1->InitMultiRefs(false); // RefCount = 1
		tcc_scatter1 = new FTccScatter();
		tcc_scatter1->InitMultiRefs(false); // RefCount = 1
	transform = new FTccVex();
	transform->InitMultiRefs(false); // RefCount = 1
}
 FTcrScatterOnBranches::~FTcrScatterOnBranches() 
{
	delete remove_attr_radius; 
	delete keep_level_1_lines_only; 
	delete tangentu; 
	delete remap_scatter_range; 
	delete foreach_begin1; 
		delete tcc_vex1; 
		delete tcc_scatter1; 
	delete transform; 
}
void FTcrScatterOnBranches::Cook() 
{
	{
		// Node: remove_attr_radius
		remove_attr_radius->SetInput(0, GetInput(0));
		remove_attr_radius->Ptdel = TEXT("radius");
		remove_attr_radius->Cook();
	}
	{
		// Node: keep_level_1_lines_only
		keep_level_1_lines_only->SetInput(0, remove_attr_radius);
		keep_level_1_lines_only->ByAttrib = 1;
		keep_level_1_lines_only->Attrib = TEXT("level");
		keep_level_1_lines_only->Op = UTccBlastByFeature::NotEqual;
		keep_level_1_lines_only->Value = 1.000000f;
		keep_level_1_lines_only->Cook();
	}
	{
		// Node: tangentu
		tangentu->SetInput(0, keep_level_1_lines_only);
		tangentu->Cook();
	}
	{
		// Node: remap_scatter_range
		remap_scatter_range->SetInput(0, tangentu);
		remap_scatter_range->Cook();
		{
			FTccGeometryPtr Geo0 = remap_scatter_range->GetGeoResult(0);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
			const FVector2f range = Range;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _curveu = attr_curveu->GetData<float>()[i];
				_curveu = vex_fit(_curveu, range.X, range.Y, 0, 1);
			}
		}
	}
	{
		// Node: foreach_begin1
		foreach_begin1->SetInput(0, remap_scatter_range);
		foreach_begin1->Itermethod = UTccForBlock::ByPiecesOrPoints;
		foreach_begin1->Method = UTccForBlock::MergeEachIteration;
		foreach_begin1->Class = UTccForBlock::Primitives;
		foreach_begin1->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = foreach_begin1->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				FTccNode* block_input0 = new FTccNode();
				block_input0->SetGeoResult(0, foreach_begin1->GetGeometryPiece(piece));
				{
					// Node: tcc_vex1
					tcc_vex1->SetInput(0, block_input0);
					tcc_vex1->SetInput(1, nullptr);
					tcc_vex1->Cook();
					{
						FTccGeometryPtr Geo0 = tcc_vex1->GetGeoResult(0);
						FTccAttribPtr attr_seed = Geo0->AddDetailAttrib("seed", ETccAttribType::I);
						const int32 gseed = Gseed;
						int32& _seed = attr_seed->GetData<int32>()[0];
						int32 iter = _iteration;
						_seed = iter * 3 + 21 + gseed;
					}
				}
				
				{
					// Node: tcc_scatter1
					tcc_scatter1->SetInput(0, tcc_vex1);
					FTccGeometryConstPtr Geo0 = tcc_scatter1->GetInput(0)->GetConstGeoResult(0);
					tcc_scatter1->Usedensityattrib = 1;
					tcc_scatter1->Densityattrib = TEXT("curveu");
					tcc_scatter1->Npts = 1;
					tcc_scatter1->ScatterSeed = int32(hs_detail(Geo0, "seed", 0));
					tcc_scatter1->Cook();
				}
				
				foreach_begin1->SetPieceResult(piece, tcc_scatter1->GetGeoResult(0));
				delete block_input0;
			}
			foreach_begin1->MergeResult();
		}
	}
	{
		// Node: transform
		transform->SetInput(0, foreach_begin1);
		transform->Cook();
		{
			FTccGeometryPtr Geo0 = transform->GetGeoResult(0);
			FTccAttribPtr attr_scale = Geo0->AddPointAttrib("scale", ETccAttribType::F3);
			FTccAttribPtr attr_tangentu = Geo0->AddPointAttrib("tangentu", ETccAttribType::F3);
			FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
			const int32 gseed = Gseed;
			const FVector3f smin = ScaleMin;
			const FVector3f smax = ScaleMax;
			const FVector3f up = vex_set(0, 1, 0);
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _scale = attr_scale->GetData<FVector3f>()[i];
				FVector3f& _tangentu = attr_tangentu->GetData<FVector3f>()[i];
				FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
				FVector3f s = vex_rand3(gseed + (_ptnum + 1) * 2.47f);
				s = vex_fit01(s, smin, smax);
				_scale = s;
				FVector3f dir = _tangentu;
				// crush vertical direction
				dir.Z = 0;// tcc_mark:replace = dir.Z / dir.Z
				dir = vex_normalize(dir);
				FMatrix44f m = vex_maketransform(dir, up);
				FVector4f q = vex_quaternion(m);
				_orient = q;
			}
		}
	}
	SetGeoResult(UTcrScatterOnBranches::output0, transform->GetGeoResult(0));
}

