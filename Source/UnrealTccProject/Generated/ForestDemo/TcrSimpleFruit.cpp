// Auto generated by UnrealTcc. 

#include "TcrSimpleFruit.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrSimpleFruit::UTcrSimpleFruit() 
{
	Shape.ResizeRampPoints(2);
	Shape.AddRampPoint(0.0000f, 1.0000f);
	Shape.AddRampPoint(1.0000f, 0.0000f);
}
FTccNodePtr UTcrSimpleFruit::CreateNode() 
{
	TSharedPtr<FTcrSimpleFruit> Node = MakeShared<FTcrSimpleFruit>();
	SyncParams(Node);
	return Node;
}
void UTcrSimpleFruit::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrSimpleFruit> Node = StaticCastSharedPtr<FTcrSimpleFruit>(InNode);
	Node->Shape = Shape;
	Node->Gseed = Gseed;
	Node->Bend = Bend;
	Node->Radx = Radx;
	Node->Rady = Rady;
	Node->Height = Height;
	Node->Rows = Rows;
	Node->Cols = Cols;
	Node->Stem = Stem;
	Node->StemCols = StemCols;
	Node->StemRows = StemRows;
}

 FTcrSimpleFruit::FTcrSimpleFruit() 
{
	InitInputsCount(0);
	tcc_cylinder1 = new FTccCylinder();
	tcc_cylinder1->InitMultiRefs(false); // RefCount = 1
	fruit_shape = new FTccVex();
	fruit_shape->InitMultiRefs(false); // RefCount = 1
	switch1 = new FTccSwitch();
	switch1->InitMultiRefs(false); // RefCount = 1
		stem = new FTccCylinder();
		stem->InitMultiRefs(false); // RefCount = 1
		tcc_merge1 = new FTccMerge();
		tcc_merge1->InitMultiRefs(false); // RefCount = 1
	tcc_bend1 = new FTccBend();
	tcc_bend1->InitMultiRefs(false); // RefCount = 1
	Shape.ResizeRampPoints(2);
	Shape.AddRampPoint(0.0000f, 1.0000f);
	Shape.AddRampPoint(1.0000f, 0.0000f);
}
 FTcrSimpleFruit::~FTcrSimpleFruit() 
{
	delete tcc_cylinder1; 
	delete fruit_shape; 
	delete switch1; 
		delete stem; 
		delete tcc_merge1; 
	delete tcc_bend1; 
}
void FTcrSimpleFruit::Cook() 
{
	{
		// Node: tcc_cylinder1
		tcc_cylinder1->Origin = FVector3f(0.000000f, Stem, 0.000000f);
		tcc_cylinder1->Direction = FVector3f(0.000000f, 1.000000f, 0.000000f);
		tcc_cylinder1->Length = float(Height);
		tcc_cylinder1->Innerradius = float(Radx);
		tcc_cylinder1->Outerradius = float(Rady);
		tcc_cylinder1->Usegments = int32(Cols);
		tcc_cylinder1->Vsegments = int32(Rows);
		tcc_cylinder1->Uv = 1;
		tcc_cylinder1->Cook();
	}
	{
		// Node: fruit_shape
		fruit_shape->SetInput(0, tcc_cylinder1);
		fruit_shape->Cook();
		{
			FTccGeometryPtr Geo0 = fruit_shape->GetGeoRef(0);
			const float h = Height;
			const float stem_len = Stem;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _P = Geo0->GetPositions()[i];
				float width_sample = Shape.Lookup((_P.Y - stem_len) / h);
				_P.X = _P.X * width_sample;
				_P.Z = _P.Z * width_sample;
			}
		}
	}
	{
		// Node: switch1
		switch1->SetInput(0, fruit_shape);
		switch1->Input = int32(Stem > 0.0f);
		switch1->NumCases = 2;
		switch1->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = switch1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: stem
					stem->Direction = FVector3f(0.000000f, 1.000000f, 0.000000f);
					stem->Length = float(Stem);
					stem->Innerradius = float(Radx * Shape.Lookup(0.0f, 0));
					stem->Outerradius = float(stem->Innerradius);
					stem->Usegments = int32(StemCols);
					stem->Vsegments = int32(StemRows);
					stem->Cook();
				}
				
				{
					// Node: tcc_merge1
					tcc_merge1->SetInput(0, fruit_shape);
					tcc_merge1->SetInput(1, stem);
					tcc_merge1->Cook();
				}
				
				SwitchResult = tcc_merge1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		switch1->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: tcc_bend1
		tcc_bend1->SetInput(0, switch1);
		tcc_bend1->Bend = float(Bend);
		tcc_bend1->Length = float(Stem);
		tcc_bend1->Cook();
	}
	SetGeoResult(UTcrSimpleFruit::output0, tcc_bend1->GetGeoResult(0));
}

