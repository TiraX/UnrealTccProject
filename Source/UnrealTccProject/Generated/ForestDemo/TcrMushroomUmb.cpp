// Auto generated by UnrealTcc. 

#include "TcrMushroomUmb.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrMushroomUmb::UTcrMushroomUmb() 
{
	ShapeTop.ResizeRampPoints(4);
	ShapeTop.AddRampPoint(0.0000f, 0.5000f);
	ShapeTop.AddRampPoint(0.0100f, 0.7368f);
	ShapeTop.AddRampPoint(0.6409f, 1.0000f);
	ShapeTop.AddRampPoint(1.0000f, 1.0000f);
	ShapeBot.ResizeRampPoints(4);
	ShapeBot.AddRampPoint(0.0000f, 0.5000f);
	ShapeBot.AddRampPoint(0.1000f, 0.5000f);
	ShapeBot.AddRampPoint(0.1898f, 0.6042f);
	ShapeBot.AddRampPoint(1.0000f, 0.5625f);
	NoiseRamp.ResizeRampPoints(2);
	NoiseRamp.AddRampPoint(0.0000f, 1.0000f);
	NoiseRamp.AddRampPoint(1.0000f, 1.0000f);
	ScatterDensity.ResizeRampPoints(2);
	ScatterDensity.AddRampPoint(0.0000f, 1.0000f);
	ScatterDensity.AddRampPoint(1.0000f, 0.0000f);
	SliceShape.ResizeRampPoints(4);
	SliceShape.AddRampPoint(0.0000f, 0.5000f);
	SliceShape.AddRampPoint(0.2618f, 0.5625f);
	SliceShape.AddRampPoint(0.7804f, 0.5833f);
	SliceShape.AddRampPoint(1.0000f, 0.4062f);
}
FTccNodePtr UTcrMushroomUmb::CreateNode() 
{
	TSharedPtr<FTcrMushroomUmb> Node = MakeShared<FTcrMushroomUmb>();
	SyncParams(Node);
	return Node;
}
void UTcrMushroomUmb::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrMushroomUmb> Node = StaticCastSharedPtr<FTcrMushroomUmb>(InNode);
	Node->ShapeTop = ShapeTop;
	Node->ShapeBot = ShapeBot;
	Node->NoiseRamp = NoiseRamp;
	Node->ScatterDensity = ScatterDensity;
	Node->SliceShape = SliceShape;
	Node->Gseed = Gseed;
	Node->R = R;
	Node->Segs = Segs;
	Node->StemInters = StemInters;
	Node->H1 = H1;
	Node->Segs1 = Segs1;
	Node->H2 = H2;
	Node->Segs2 = Segs2;
	Node->Amp = Amp;
	Node->Freq = Freq;
	Node->EnableScatter = EnableScatter;
	Node->FastRemoveR = FastRemoveR;
	Node->Npts = Npts;
	Node->RotRange = RotRange;
	Node->SScale = SScale;
	Node->SScaleR = SScaleR;
	Node->EnableSlice = EnableSlice;
	Node->SliceCount = SliceCount;
	Node->SliceSegs = SliceSegs;
	Node->SliceAmph = SliceAmph;
	Node->SliceFreqh = SliceFreqh;
	Node->SliceAmpv = SliceAmpv;
	Node->SliceFreqv = SliceFreqv;
}

 FTcrMushroomUmb::FTcrMushroomUmb() 
{
	InitInputsCount(2);
	umbrella_line = new FTccVex();
	umbrella_line->InitMultiRefs(false); // RefCount = 1
	shape = new FTccVex();
	shape->InitMultiRefs(false); // RefCount = 1
	tcc_copy_and_trans1 = new FTccCopyAndTrans();
	tcc_copy_and_trans1->InitMultiRefs(false); // RefCount = 1
	tcc_poly_frame1 = new FTccPolyFrame();
	tcc_poly_frame1->InitMultiRefs(false); // RefCount = 1
	tcc_skin3 = new FTccSkin();
	tcc_skin3->InitMultiRefs(false); // RefCount = 1
	mi_trunk = new FTccUnrealMaterial();
	mi_trunk->InitMultiRefs(false); // RefCount = 1
	enable_slice = new FTccSwitch();
	enable_slice->InitMultiRefs(false); // RefCount = 1
		slice = new FTccVex();
		slice->InitMultiRefs(false); // RefCount = 1
		tcc_copy_and_trans2 = new FTccCopyAndTrans();
		tcc_copy_and_trans2->InitMultiRefs(false); // RefCount = 1
		slice_noise1 = new FTccVex();
		slice_noise1->InitMultiRefs(false); // RefCount = 1
		mi_leaf = new FTccUnrealMaterial();
		mi_leaf->InitMultiRefs(false); // RefCount = 1
		merge_slice = new FTccMerge();
		merge_slice->InitMultiRefs(false); // RefCount = 1
	enable_noise = new FTccSwitch();
	enable_noise->InitMultiRefs(false); // RefCount = 1
		apply_noise = new FTccVex();
		apply_noise->InitMultiRefs(false); // RefCount = 1
	tcc_normal1 = new FTccNormal();
	tcc_normal1->InitMultiRefs(false); // RefCount = 1
	calc_stem_info = new FTccVex();
	calc_stem_info->InitMultiRefs(false); // RefCount = 1
	move_to_stem = new FTccVex();
	move_to_stem->InitMultiRefs(false); // RefCount = 1
	tcc_merge6 = new FTccMerge();
	tcc_merge6->InitMultiRefs(true); // RefCount = 2
	has_scatter1 = new FTccSwitch();
	has_scatter1->InitMultiRefs(false); // RefCount = 1
		tcc_pack7 = new FTccPack();
		tcc_pack7->InitMultiRefs(false); // RefCount = 1
		tcc_sphere2 = new FTccSphere();
		tcc_sphere2->InitMultiRefs(false); // RefCount = 1
		tcc_subdivide2 = new FTccSubdivide();
		tcc_subdivide2->InitMultiRefs(true); // RefCount = 3
		tcc_mountain4 = new FTccMountain();
		tcc_mountain4->InitMultiRefs(false); // RefCount = 1
		mi_trunk1 = new FTccUnrealMaterial();
		mi_trunk1->InitMultiRefs(false); // RefCount = 1
		tcc_pack4 = new FTccPack();
		tcc_pack4->InitMultiRefs(false); // RefCount = 1
		tcc_mountain5 = new FTccMountain();
		tcc_mountain5->InitMultiRefs(false); // RefCount = 1
		mi_trunk2 = new FTccUnrealMaterial();
		mi_trunk2->InitMultiRefs(false); // RefCount = 1
		tcc_pack5 = new FTccPack();
		tcc_pack5->InitMultiRefs(false); // RefCount = 1
		tcc_mountain6 = new FTccMountain();
		tcc_mountain6->InitMultiRefs(false); // RefCount = 1
		mi_trunk3 = new FTccUnrealMaterial();
		mi_trunk3->InitMultiRefs(false); // RefCount = 1
		tcc_pack6 = new FTccPack();
		tcc_pack6->InitMultiRefs(false); // RefCount = 1
		tcc_merge4 = new FTccMerge();
		tcc_merge4->InitMultiRefs(false); // RefCount = 1
		keep_top_only1 = new FTccBlastByFeature();
		keep_top_only1->InitMultiRefs(false); // RefCount = 1
		density1 = new FTccVex();
		density1->InitMultiRefs(false); // RefCount = 1
		tcc_scatter2 = new FTccScatter();
		tcc_scatter2->InitMultiRefs(false); // RefCount = 1
		tcc_attrib_delete2 = new FTccAttribDelete();
		tcc_attrib_delete2->InitMultiRefs(false); // RefCount = 1
		transform_and_id1 = new FTccVex();
		transform_and_id1->InitMultiRefs(false); // RefCount = 1
		tcc_instancer2 = new FTccInstancer();
		tcc_instancer2->InitMultiRefs(false); // RefCount = 1
		tcc_merge5 = new FTccMerge();
		tcc_merge5->InitMultiRefs(false); // RefCount = 1
	ShapeTop.ResizeRampPoints(4);
	ShapeTop.AddRampPoint(0.0000f, 0.5000f);
	ShapeTop.AddRampPoint(0.0100f, 0.7368f);
	ShapeTop.AddRampPoint(0.6409f, 1.0000f);
	ShapeTop.AddRampPoint(1.0000f, 1.0000f);
	ShapeBot.ResizeRampPoints(4);
	ShapeBot.AddRampPoint(0.0000f, 0.5000f);
	ShapeBot.AddRampPoint(0.1000f, 0.5000f);
	ShapeBot.AddRampPoint(0.1898f, 0.6042f);
	ShapeBot.AddRampPoint(1.0000f, 0.5625f);
	NoiseRamp.ResizeRampPoints(2);
	NoiseRamp.AddRampPoint(0.0000f, 1.0000f);
	NoiseRamp.AddRampPoint(1.0000f, 1.0000f);
	ScatterDensity.ResizeRampPoints(2);
	ScatterDensity.AddRampPoint(0.0000f, 1.0000f);
	ScatterDensity.AddRampPoint(1.0000f, 0.0000f);
	SliceShape.ResizeRampPoints(4);
	SliceShape.AddRampPoint(0.0000f, 0.5000f);
	SliceShape.AddRampPoint(0.2618f, 0.5625f);
	SliceShape.AddRampPoint(0.7804f, 0.5833f);
	SliceShape.AddRampPoint(1.0000f, 0.4062f);
}
 FTcrMushroomUmb::~FTcrMushroomUmb() 
{
	delete umbrella_line; 
	delete shape; 
	delete tcc_copy_and_trans1; 
	delete tcc_poly_frame1; 
	delete tcc_skin3; 
	delete mi_trunk; 
	delete enable_slice; 
		delete slice; 
		delete tcc_copy_and_trans2; 
		delete slice_noise1; 
		delete mi_leaf; 
		delete merge_slice; 
	delete enable_noise; 
		delete apply_noise; 
	delete tcc_normal1; 
	delete calc_stem_info; 
	delete move_to_stem; 
	delete tcc_merge6; 
	delete has_scatter1; 
		delete tcc_pack7; 
		delete tcc_sphere2; 
		delete tcc_subdivide2; 
		delete tcc_mountain4; 
		delete mi_trunk1; 
		delete tcc_pack4; 
		delete tcc_mountain5; 
		delete mi_trunk2; 
		delete tcc_pack5; 
		delete tcc_mountain6; 
		delete mi_trunk3; 
		delete tcc_pack6; 
		delete tcc_merge4; 
		delete keep_top_only1; 
		delete density1; 
		delete tcc_scatter2; 
		delete tcc_attrib_delete2; 
		delete transform_and_id1; 
		delete tcc_instancer2; 
		delete tcc_merge5; 
}
void FTcrMushroomUmb::Cook() 
{
	{
		// Node: umbrella_line
		umbrella_line->SetInput(0, nullptr);
		umbrella_line->SetInput(1, GetInput(0));
		umbrella_line->Cook();
		{
			FTccGeometryPtr Geo0 = umbrella_line->GetGeoRef(0);
			FTccGeometryConstPtr Geo1 = GetInput(0)->GetConstGeoResult(0);
			const float r_umb = R;
			const float r_stem = vex_detailf(Geo1, "stem_r") * 0.9f;
			const int32 segs_top = Segs1;
			const int32 segs_bot = Segs2;
			float ustep_top = 1.f / segs_top;
			float ustep_bot = 1.f / segs_bot;
			float step_top = r_umb * ustep_top;
			float step_bot = (r_umb - r_stem) * ustep_bot;
			float angle_step_top = PI * 0.5f * ustep_top;
			int32 num_pts = segs_top + segs_bot + 1;
			TArray < FVector3f > poses;
			TArray < int32 > mark;
			TArray < float > curveu;
			vex_resize(poses, num_pts);
			vex_resize(mark, num_pts);
			vex_resize(curveu, num_pts);
			//start from bottom
			FVector3f pos = vex_set(0, 0.f,  - r_stem);
			float u = 1.f;
			int32 pt_index = 0;
			for(pt_index = 0;pt_index < segs_bot;pt_index ++)
			{
			poses [ pt_index] = pos;
			curveu [ pt_index] = u;
			mark [ pt_index] =  - 1;
			pos.Y -= step_bot;// tcc_mark:replace=.Y / .Y
			u -= ustep_bot;
			}
			// edge pt
			pos = vex_set(0, 0.f,  - r_umb);
			u = 0.f;
			poses [ pt_index] = pos;
			curveu [ pt_index] = u;
			mark [ pt_index] = 1;
			pt_index ++;
			// go to top
			float angle = 0.f;
			for(;pt_index < num_pts;pt_index ++)
			{
			angle += angle_step_top;
			float cos_pos = cos(angle);
			    // use cosine distribute
			pos.Y =  - cos_pos * r_umb;// tcc_mark:replace=.Y / .Y
			u = 1.f - cos_pos;
			    //pos.z += step_top;  //tcc_mark:replace=.z/.y
			    //u += ustep_top;
			poses [ pt_index] = pos;
			curveu [ pt_index] = u;
			mark [ pt_index] = 1;
			}
			TArray < int32 > pts= vex_addpoints(Geo0, poses);
			vex_setpointsattrib(Geo0, "curveu", pts, curveu);
			vex_setpointsattrib(Geo0, "mark", pts, mark);
			vex_addprim(Geo0, "polyline", pts);
		}
	}
	{
		// Node: shape
		shape->SetInput(0, umbrella_line);
		shape->Cook();
		{
			FTccGeometryPtr Geo0 = shape->GetGeoRef(0);
			FTccAttribPtr attr_mark = Geo0->AddPointAttrib("mark", ETccAttribType::I);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
			const float h_top = H1;
			const float h_bot = H2;
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _P = Geo0->GetPositions()[i];
				int32& _mark = attr_mark->GetData<int32>()[i];
				float& _curveu = attr_curveu->GetData<float>()[i];
				float offset = 0.f;
				if(_mark > 0)
				{
				    // top
				offset = (ShapeTop.Lookup(_curveu) * 2.f - 1.f) * h_top;
				}
				else if(_mark < 0)
				{
				    // bottom
				offset = (ShapeBot.Lookup(_curveu) * 2.f - 1.f) * h_bot;
				}
				else
				{
				    // edge point, fixed.
				}
				_P.Z += offset;// _P.Z will be replaced to _P.Y automatically
			}
		}
	}
	{
		// Node: tcc_copy_and_trans1
		tcc_copy_and_trans1->SetInput(0, shape);
		tcc_copy_and_trans1->Ncy = int32(Segs);
		tcc_copy_and_trans1->R = FVector3f(0.000000f, 0.000000f, 360.0f / tcc_copy_and_trans1->Ncy);
		tcc_copy_and_trans1->Cook();
	}
	{
		// Node: tcc_poly_frame1
		tcc_poly_frame1->SetInput(0, tcc_copy_and_trans1);
		tcc_poly_frame1->Cook();
	}
	{
		// Node: tcc_skin3
		tcc_skin3->SetInput(0, tcc_poly_frame1);
		tcc_skin3->Closev = UTccSkin::On;
		tcc_skin3->Cook();
	}
	{
		// Node: mi_trunk
		mi_trunk->SetInput(0, tcc_skin3);
		mi_trunk->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Trunk.MI_TreeBig_Trunk");
		mi_trunk->Cook();
	}
	{
		// Node: enable_slice
		enable_slice->SetInput(0, mi_trunk);
		enable_slice->Input = int32(EnableSlice);
		enable_slice->NumCases = 2;
		enable_slice->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_slice->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: slice
					slice->SetInput(0, nullptr);
					slice->SetInput(1, GetInput(0));
					slice->Cook();
					{
						FTccGeometryPtr Geo0 = slice->GetGeoRef(0);
						FTccGeometryConstPtr Geo1 = GetInput(0)->GetConstGeoResult(0);
						const float r_umb = R * 0.96f;
						const float r_stem = vex_detailf(Geo1, "stem_r") * 0.9f;
						const float h_bot = H2;
						const int32 segs = SliceSegs;
						float ustep_bot = 1.f / segs;
						float step_bot = (r_umb - r_stem) * ustep_bot;
						int32 num_pts = (segs + 1) * 2;
						TArray < FVector3f > poses;
						TArray < float > curveus;
						TArray < float > noise_weights;
						vex_resize(poses, num_pts);
						vex_resize(curveus, num_pts);
						vex_resize(noise_weights, num_pts);
						FVector3f pos = vex_set(0.f, 0.f,  - r_umb);
						float u = 0.f;
						int32 pt_index = 0;
						for(;pt_index < segs + 1;pt_index ++)
						{
						int32 idx = pt_index * 2;
						    // slice top, stick to mushroom bottom
						pos.Z = (ShapeBot.Lookup(u) * 2.f - 1.f) * h_bot;// tcc_mark:replace=.Z / .Z
						poses [ idx] = pos;
						curveus [ idx] = u;
						noise_weights [ idx] = 0.f;
						    // slice bottom
						pos.Z = (SliceShape.Lookup(u) * 2.f - 1.f) * h_bot;// tcc_mark:replace=.Z / .Z
						poses [ idx + 1] = pos;
						curveus [ idx + 1] = u;
						noise_weights [ idx + 1] = pt_index == 0 ? 0.f : 1.f;
						pos.Y += step_bot;// tcc_mark:replace=.Y / .Y
						u += ustep_bot;
						}
						TArray < int32 > pts= vex_addpoints(Geo0, poses);
						vex_setpointsattrib(Geo0, "noise_weight", pts, noise_weights);
						vex_setpointsattrib(Geo0, "curveu", pts, curveus);
						// create triangles
						TArray < int32 > tris;
						vex_resize(tris, segs * 2 * 3);
						int32 idx = 0;
						for(int i = 0;i < segs;i ++)
						{
						int32 p00, p10, p01, p11;
						p00 = i * 2;
						p10 = p00 + 1;
						p01 = (i + 1) * 2;
						p11 = p01 + 1;
						tris [ idx ++ ] = p00;
						tris [ idx ++ ] = p10;
						tris [ idx ++ ] = p01;
						tris [ idx ++ ] = p10;
						tris [ idx ++ ] = p11;
						tris [ idx ++ ] = p01;
						}
						vex_addprims(Geo0, "poly", tris);
					}
				}
				
				{
					// Node: tcc_copy_and_trans2
					tcc_copy_and_trans2->SetInput(0, slice);
					tcc_copy_and_trans2->Ncy = int32(SliceCount);
					tcc_copy_and_trans2->R = FVector3f(0.000000f, 0.000000f, 360.0f / tcc_copy_and_trans2->Ncy);
					tcc_copy_and_trans2->Cook();
				}
				
				{
					// Node: slice_noise1
					slice_noise1->SetInput(0, tcc_copy_and_trans2);
					slice_noise1->Cook();
					{
						FTccGeometryPtr Geo0 = slice_noise1->GetGeoRef(0);
						FTccAttribPtr attr_noise_weight = Geo0->AddPointAttrib("noise_weight", ETccAttribType::F);
						const int32 seed = Gseed + 485;
						const float ampv = SliceAmpv;
						const float freqv = SliceFreqv;
						const float amph = SliceAmph;
						const float freqh = SliceFreqh;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _noise_weight = attr_noise_weight->GetData<float>()[i];
							FVector3f pos_seedv = _P * freqv + float(seed);
							float nz = vex_noise(pos_seedv) * ampv;
							FVector3f pos_seedh = _P * freqh + float(seed);
							FVector3f nxy = vex_curlnoise2d(pos_seedh) * amph;
							FVector3f n = vex_set(nxy.X, nz, nxy.Y);
							_P -= n * _noise_weight;
						}
					}
				}
				
				{
					// Node: mi_leaf
					mi_leaf->SetInput(0, slice_noise1);
					mi_leaf->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Leaf.MI_TreeBig_Leaf");
					mi_leaf->Cook();
				}
				
				{
					// Node: merge_slice
					merge_slice->SetInput(0, mi_trunk);
					merge_slice->SetInput(1, mi_leaf);
					merge_slice->Cook();
				}
				
				SwitchResult = merge_slice->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_slice->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: enable_noise
		enable_noise->SetInput(0, enable_slice);
		enable_noise->Input = int32(Amp > 0);
		enable_noise->NumCases = 2;
		enable_noise->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = enable_noise->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: apply_noise
					apply_noise->SetInput(0, enable_slice);
					apply_noise->Cook();
					{
						FTccGeometryPtr Geo0 = apply_noise->GetGeoRef(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", ETccAttribType::F);
						const int32 seed = Gseed;
						const float a = Amp;
						const float f = Freq;
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector3f vseed = vex_set(seed, seed, seed);
							FVector3f pseed = _P * f;
							pseed.Z = 0.f;// tcc_mark:replace=.Z / .Z
							pseed += vseed;
							float n = (vex_noise(pseed) * 2.f - 1.f) * a * NoiseRamp.Lookup(_curveu);
							_P.Z += n;
						}
					}
				}
				
				SwitchResult = apply_noise->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_noise->SetValidGeoResult(0, SwitchResult);
	}
	{
		// Node: tcc_normal1
		tcc_normal1->SetInput(0, enable_noise);
		tcc_normal1->Cook();
	}
	{
		// Node: calc_stem_info
		calc_stem_info->SetInput(0, tcc_normal1);
		calc_stem_info->SetInput(1, GetInput(0));
		calc_stem_info->Cook();
		{
			FTccGeometryPtr Geo0 = calc_stem_info->GetGeoRef(0);
			FTccGeometryConstPtr Geo1 = GetInput(0)->GetConstGeoResult(0);
			FTccAttribPtr attr_trans = Geo0->AddDetailAttrib("trans", ETccAttribType::F3);
			FTccAttribPtr attr_rot = Geo0->AddDetailAttrib("rot", ETccAttribType::F4);
			FVector3f& _trans = attr_trans->GetData<FVector3f>()[0];
			FVector4f& _rot = attr_rot->GetData<FVector4f>()[0];
			FVector3f end_pt = vex_detailv(Geo1, "end_point");
			FVector3f dir = vex_detailv(Geo1, "end_dir");
			float intersection = StemInters;
			intersection += (ShapeBot.Lookup(1.f) * 2.f - 1.f) * H2;
			_trans = end_pt - dir * intersection;
			FVector3f up = vex_set(0, 1, 0);
			_rot = vex_dihedral(up, dir);
		}
	}
	{
		// Node: move_to_stem
		move_to_stem->SetInput(0, calc_stem_info);
		move_to_stem->Cook();
		{
			FTccGeometryPtr Geo0 = move_to_stem->GetGeoRef(0);
			const FVector3f pos = vex_detailv(Geo0, "trans");
			const FVector4f rot = vex_detailp(Geo0, "rot");
			const int32 _numpt = Geo0->GetNumPoints();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				FVector3f& _P = Geo0->GetPositions()[i];
				_P = vex_qrotate(rot, _P);
				_P += pos;
			}
		}
	}
	{
		// Node: tcc_merge6
		tcc_merge6->SetInput(0, move_to_stem);
		tcc_merge6->SetInput(1, GetInput(0));
		tcc_merge6->Cook();
	}
	{
		// Node: has_scatter1
		has_scatter1->SetInput(0, tcc_merge6);
		has_scatter1->Input = int32(EnableScatter);
		has_scatter1->NumCases = 2;
		has_scatter1->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = has_scatter1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					// Node: tcc_pack7
					tcc_pack7->SetInput(0, tcc_merge6);
					tcc_pack7->GeoName = TEXT("mushroom");
					tcc_pack7->Cook();
				}
				
				{
					// Node: tcc_sphere2
					tcc_sphere2->Rad = FVector3f(0.400000f, 0.200000f, 0.500000f);
					tcc_sphere2->Rows = 4;
					tcc_sphere2->Cols = 4;
					tcc_sphere2->Cook();
				}
				
				{
					// Node: tcc_subdivide2
					tcc_subdivide2->SetInput(0, tcc_sphere2);
					tcc_subdivide2->Uv = 0;
					tcc_subdivide2->Cook();
				}
				
				{
					// Node: tcc_mountain4
					tcc_mountain4->SetInput(0, tcc_subdivide2);
					tcc_mountain4->Amplitude = 0.290000f;
					tcc_mountain4->Elementsize = 0.450000f;
					tcc_mountain4->Cook();
				}
				
				{
					// Node: mi_trunk1
					mi_trunk1->SetInput(0, tcc_mountain4);
					mi_trunk1->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Trunk.MI_TreeBig_Trunk");
					mi_trunk1->Cook();
				}
				
				{
					// Node: tcc_pack4
					tcc_pack4->SetInput(0, mi_trunk1);
					tcc_pack4->GeoName = TEXT("dot0");
					tcc_pack4->EnableId = 1;
					tcc_pack4->Cook();
				}
				
				{
					// Node: tcc_mountain5
					tcc_mountain5->SetInput(0, tcc_subdivide2);
					tcc_mountain5->Amplitude = 0.290000f;
					tcc_mountain5->Elementsize = 0.450000f;
					tcc_mountain5->Offset = 17.410000f;
					tcc_mountain5->Cook();
				}
				
				{
					// Node: mi_trunk2
					mi_trunk2->SetInput(0, tcc_mountain5);
					mi_trunk2->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Trunk.MI_TreeBig_Trunk");
					mi_trunk2->Cook();
				}
				
				{
					// Node: tcc_pack5
					tcc_pack5->SetInput(0, mi_trunk2);
					tcc_pack5->GeoName = TEXT("dot1");
					tcc_pack5->EnableId = 1;
					tcc_pack5->InsId = 1;
					tcc_pack5->Cook();
				}
				
				{
					// Node: tcc_mountain6
					tcc_mountain6->SetInput(0, tcc_subdivide2);
					tcc_mountain6->Amplitude = 0.290000f;
					tcc_mountain6->Elementsize = 0.450000f;
					tcc_mountain6->Offset = 44.650002f;
					tcc_mountain6->Cook();
				}
				
				{
					// Node: mi_trunk3
					mi_trunk3->SetInput(0, tcc_mountain6);
					mi_trunk3->MatPath = TEXT("/Game/ForestDemo/Materials/MI_TreeBig_Trunk.MI_TreeBig_Trunk");
					mi_trunk3->Cook();
				}
				
				{
					// Node: tcc_pack6
					tcc_pack6->SetInput(0, mi_trunk3);
					tcc_pack6->GeoName = TEXT("dot2");
					tcc_pack6->EnableId = 1;
					tcc_pack6->InsId = 2;
					tcc_pack6->Cook();
				}
				
				{
					// Node: tcc_merge4
					tcc_merge4->SetInput(0, tcc_pack4);
					tcc_merge4->SetInput(1, tcc_pack5);
					tcc_merge4->SetInput(2, tcc_pack6);
					tcc_merge4->Cook();
				}
				
				{
					// Node: keep_top_only1
					keep_top_only1->SetInput(0, tcc_merge6);
					keep_top_only1->Grouptype = UTccBlastByFeature::Points;
					keep_top_only1->ByAttrib = 1;
					keep_top_only1->Attrib = TEXT("mark");
					keep_top_only1->Op = UTccBlastByFeature::LessEqual;
					keep_top_only1->Cook();
				}
				
				{
					// Node: density1
					density1->SetInput(0, keep_top_only1);
					density1->Cook();
					{
						FTccGeometryPtr Geo0 = density1->GetGeoRef(0);
						FTccAttribPtr attr_density = Geo0->AddPrimAttrib("density", ETccAttribType::F);
						const int32 _numprim = Geo0->GetNumPrims();
						for(int32 i = 0; i < _numprim; i++)
						{
							const int32 _primnum = i;
							float& _density = attr_density->GetData<float>()[i];
							TArray < int32 > pts= vex_primpoints(Geo0, _primnum);
							float u0 = vex_pointf(Geo0, "curveu", pts [ 0]);
							float u1 = vex_pointf(Geo0, "curveu", pts [ 1]);
							float u2 = vex_pointf(Geo0, "curveu", pts [ 2]);
							float d = (u0 + u1 + u2) / 3.f;
							_density = ScatterDensity.Lookup(d);
						}
					}
				}
				
				{
					// Node: tcc_scatter2
					tcc_scatter2->SetInput(0, density1);
					tcc_scatter2->Usedensityattrib = 1;
					tcc_scatter2->Npts = int32(Npts);
					tcc_scatter2->ScatterSeed = int32(Gseed);
					tcc_scatter2->FastRemove = 1;
					tcc_scatter2->FastRemoveR = float(FastRemoveR);
					tcc_scatter2->Cook();
				}
				
				{
					// Node: tcc_attrib_delete2
					tcc_attrib_delete2->SetInput(0, tcc_scatter2);
					tcc_attrib_delete2->Ptdel = TEXT("mark");
					tcc_attrib_delete2->Cook();
				}
				
				{
					// Node: transform_and_id1
					transform_and_id1->SetInput(0, tcc_attrib_delete2);
					transform_and_id1->Cook();
					{
						FTccGeometryPtr Geo0 = transform_and_id1->GetGeoRef(0);
						FTccAttribPtr attr_N = Geo0->AddPointAttrib("N", ETccAttribType::F3);
						FTccAttribPtr attr_tangentu = Geo0->AddPointAttrib("tangentu", ETccAttribType::F3);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", ETccAttribType::F4);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", ETccAttribType::F);
						FTccAttribPtr attr_instance_id = Geo0->AddPointAttrib("instance_id", ETccAttribType::I);
						const int32 seed = Gseed;
						const float scale = SScale;
						const float scale_r = SScaleR;
						const float rot = vex_radians(RotRange);
						const int32 _numpt = Geo0->GetNumPoints();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _N = attr_N->GetData<FVector3f>()[i];
							FVector3f& _tangentu = attr_tangentu->GetData<FVector3f>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							float& _pscale = attr_pscale->GetData<float>()[i];
							int32& _instance_id = attr_instance_id->GetData<int32>()[i];
							int32 local_seed = seed + _ptnum;
							// rotate
							FMatrix44f m = vex_maketransform(_N, _tangentu);
							FVector4f q = vex_quaternion(m);
							float rot_angle = vex_fit01(vex_rand(local_seed + 91),  - rot, rot);
							FVector4f qrot = vex_quaternion(rot_angle, _N);
							q = vex_qmultiply(qrot, q);
							_orient = q;
							// scale
							float s_r = vex_fit01(vex_rand(local_seed + 38), 1.f - scale_r, 1.f + scale_r);
							_pscale = scale * s_r;
							// id
							_instance_id = (int)(vex_rand(local_seed + 83) * 2.99f);
						}
					}
				}
				
				{
					// Node: tcc_instancer2
					tcc_instancer2->SetInput(0, tcc_merge4);
					tcc_instancer2->SetInput(1, transform_and_id1);
					tcc_instancer2->Useidattrib = 1;
					tcc_instancer2->Cook();
				}
				
				{
					// Node: tcc_merge5
					tcc_merge5->SetInput(0, tcc_pack7);
					tcc_merge5->SetInput(1, tcc_instancer2);
					tcc_merge5->Cook();
				}
				
				SwitchResult = tcc_merge5->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		has_scatter1->SetValidGeoResult(0, SwitchResult);
	}
	SetGeoResult(UTcrMushroomUmb::output0, has_scatter1->GetGeoResult(0));
}

