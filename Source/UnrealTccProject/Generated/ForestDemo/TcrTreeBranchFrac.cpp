// Auto generated by UnrealTcc. 

#include "TcrTreeBranchFrac.h"
#include "TcrTreeBranchFracLevel.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TctTexVex.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTreeBranchFrac::UTcrTreeBranchFrac() 
{
}
FTccNodePtr UTcrTreeBranchFrac::CreateNode() 
{
	TSharedPtr<FTcrTreeBranchFrac> Node = MakeShared<FTcrTreeBranchFrac>();
	SyncParams(Node);
	return Node;
}
void UTcrTreeBranchFrac::SyncParams(FTccNodePtr InNode) 
{
	TSharedPtr<FTcrTreeBranchFrac> Node = StaticCastSharedPtr<FTcrTreeBranchFrac>(InNode);
	Node->Gseed = Gseed;
	Node->PitchBase = PitchBase;
	Node->Sep = Sep;
	Node->SplitDis = SplitDis;
	Node->SplitDisFalloff = SplitDisFalloff;
	Node->Angle = Angle;
	Node->Roll = Roll;
	Node->Force = Force;
}

 FTcrTreeBranchFrac::FTcrTreeBranchFrac() 
{
	InitInputsCount(1);
	frac_base = new FTccVex();
	frac_base->InitMultiRefs(true); // RefCount = 2
	frac1 = new FTcrTreeBranchFracLevel();
	frac1->InitMultiRefs(true); // RefCount = 2
	frac2 = new FTcrTreeBranchFracLevel();
	frac2->InitMultiRefs(true); // RefCount = 2
	frac3 = new FTcrTreeBranchFracLevel();
	frac3->InitMultiRefs(true); // RefCount = 2
	frac4 = new FTcrTreeBranchFracLevel();
	frac4->InitMultiRefs(true); // RefCount = 2
	frac5 = new FTcrTreeBranchFracLevel();
	frac5->InitMultiRefs(true); // RefCount = 2
	frac6 = new FTcrTreeBranchFracLevel();
	frac6->InitMultiRefs(true); // RefCount = 2
	frac7 = new FTcrTreeBranchFracLevel();
	frac7->InitMultiRefs(false); // RefCount = 1
	tcc_merge1 = new FTccMerge();
	tcc_merge1->InitMultiRefs(false); // RefCount = 1
	tcc_attrib_delete1 = new FTccAttribDelete();
	tcc_attrib_delete1->InitMultiRefs(false); // RefCount = 1
}
 FTcrTreeBranchFrac::~FTcrTreeBranchFrac() 
{
	delete frac_base; 
	delete frac1; 
	delete frac2; 
	delete frac3; 
	delete frac4; 
	delete frac5; 
	delete frac6; 
	delete frac7; 
	delete tcc_merge1; 
	delete tcc_attrib_delete1; 
}
void FTcrTreeBranchFrac::Cook() 
{
	{
		// Node: frac_base
		FTccRampFloat _force_ramp = ETccRampInterp::Linear;
		_force_ramp.ResizeRampPoints(3);
		_force_ramp.AddRampPoint(0.0000f, 0.0000f);
		_force_ramp.AddRampPoint(0.8658f, 0.0000f);
		_force_ramp.AddRampPoint(1.0000f, 1.0000f);
		FTccRampFloat _radius_shape = ETccRampInterp::Linear;
		_radius_shape.ResizeRampPoints(2);
		_radius_shape.AddRampPoint(0.0000f, 1.0000f);
		_radius_shape.AddRampPoint(1.0000f, 0.7000f);
		float _sep = float(Sep);
		float _split_dis = float(SplitDis);
		float _force = 0.000000f;
		float _radius_base = 0.100000f;
		frac_base->Cook();
		{
			FTccGeometryPtr Geo0 = frac_base->GetGeoRef(0);
			const float pitch_base = vex_radians(PitchBase);
			const float eps = 0.01f;
			FVector3f origin = vex_set(0, 0, 0);
			FVector3f dir = vex_set(0, sin(pitch_base), cos(pitch_base));
			FVector3f force_dir = vex_set(0, 1, 0);
			float age_start = 0.f;
			float parent_radius = _radius_base;
			float sep = _sep;
			float split_dis = _split_dis;
			float split_dis_falloff = 1.f;
			float inv_split_dis = 1.f / split_dis;
			// float angle;
			// float roll;
			float force = _force;
			// int force_level;
			TArray < FVector3f > points;
			TArray < float > ages;
			TArray < float > rads;
			TArray < FVector3f > dirs;
			int32 total_segs = (int)(split_dis / sep);
			if(split_dis - sep * total_segs > eps)
			total_segs ++;
			int32 total_pts = total_segs + 1;
			vex_resize(points, total_pts);
			vex_resize(ages, total_pts);
			vex_resize(rads, total_pts);
			vex_resize(dirs, total_pts);
			float dis = 0.f;
			float r = parent_radius;
			FVector3f pos = origin;
			int32 pt_index = 0;
			while(dis < split_dis)
			{
			points [ pt_index] = pos;
			ages [ pt_index] = age_start + dis;
			dirs [ pt_index] = dir;
			dis += sep;
			    
			rads [ pt_index] = r;
			float ramp_pos = dis * inv_split_dis;
			r = parent_radius * _radius_shape.Lookup(ramp_pos);
			    
			    // update dir by force
			if(force > 0.f)
			{
			float strength = _force_ramp.Lookup(ramp_pos);
			dir = vex_normalize(dir + force_dir * force * strength);
			}
			    
			pos += dir * sep;
			    
			++ pt_index;
			}
			// add last point
			float tail = split_dis - dis + sep;
			if(tail > eps)
			{
			pos = points [ pt_index - 1] + dir * tail;
			float age = ages [ pt_index - 1] + tail;
			points [ pt_index] = pos;
			ages [ pt_index] = age;
			rads [ pt_index] = parent_radius * _radius_shape.Lookup(1.0f);
			dirs [ pt_index] = dir;
			}
			TArray < int32 > pts= vex_addpoints(Geo0, points);
			vex_setpointsattrib(Geo0, "age", pts, ages);
			vex_setpointsattrib(Geo0, "radius", pts, rads);
			vex_setpointsattrib(Geo0, "dir", pts, dirs);
			int32 frac_line = vex_addprim(Geo0, "polyline", pts);
			vex_setprimattrib(Geo0, "frac_level", frac_line, 0);
			vex_setprimattrib(Geo0, "oddeven", frac_line, 1.f);
		}
	}
	{
		// Node: frac1
		frac1->SetInput(0, frac_base);
		frac1->ForceRamp = ETccRampInterp::Linear;
		frac1->ForceRamp.ResizeRampPoints(3);
		frac1->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac1->ForceRamp.AddRampPoint(0.7424f, 0.0000f);
		frac1->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac1->RadiusShape = ETccRampInterp::Linear;
		frac1->RadiusShape.ResizeRampPoints(2);
		frac1->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac1->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac1->Sep = float(Sep);
		frac1->SplitDis = float(SplitDis * SplitDisFalloff);
		frac1->Angle = float(Angle);
		frac1->Roll = 36.700001f;
		frac1->Force = float(Force);
		frac1->Cook();
	}
	{
		// Node: frac2
		frac2->SetInput(0, frac1);
		frac2->ForceRamp = ETccRampInterp::Linear;
		frac2->ForceRamp.ResizeRampPoints(3);
		frac2->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac2->ForceRamp.AddRampPoint(0.7760f, 0.0000f);
		frac2->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac2->RadiusShape = ETccRampInterp::Linear;
		frac2->RadiusShape.ResizeRampPoints(2);
		frac2->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac2->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac2->Sep = float(Sep);
		frac2->SplitDis = float(frac1->SplitDis * SplitDisFalloff);
		frac2->Angle = float(Angle);
		frac2->Roll = 48.400002f;
		frac2->Force = float(Force);
		frac2->Cook();
	}
	{
		// Node: frac3
		frac3->SetInput(0, frac2);
		frac3->ForceRamp = ETccRampInterp::Linear;
		frac3->ForceRamp.ResizeRampPoints(3);
		frac3->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac3->ForceRamp.AddRampPoint(0.5328f, 0.0000f);
		frac3->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac3->RadiusShape = ETccRampInterp::Linear;
		frac3->RadiusShape.ResizeRampPoints(2);
		frac3->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac3->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac3->Sep = float(Sep);
		frac3->SplitDis = float(frac2->SplitDis * SplitDisFalloff);
		frac3->Angle = float(Angle);
		frac3->Roll = 35.500000f;
		frac3->Force = float(Force);
		frac3->Cook();
	}
	{
		// Node: frac4
		frac4->SetInput(0, frac3);
		frac4->ForceRamp = ETccRampInterp::Linear;
		frac4->ForceRamp.ResizeRampPoints(3);
		frac4->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac4->ForceRamp.AddRampPoint(0.8658f, 0.0000f);
		frac4->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac4->RadiusShape = ETccRampInterp::Linear;
		frac4->RadiusShape.ResizeRampPoints(2);
		frac4->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac4->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac4->Sep = float(Sep);
		frac4->SplitDis = float(frac3->SplitDis * SplitDisFalloff);
		frac4->Angle = float(Angle);
		frac4->Roll = 54.799999f;
		frac4->Force = float(Force);
		frac4->Cook();
	}
	{
		// Node: frac5
		frac5->SetInput(0, frac4);
		frac5->ForceRamp = ETccRampInterp::Linear;
		frac5->ForceRamp.ResizeRampPoints(3);
		frac5->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac5->ForceRamp.AddRampPoint(0.8658f, 0.0000f);
		frac5->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac5->RadiusShape = ETccRampInterp::Linear;
		frac5->RadiusShape.ResizeRampPoints(2);
		frac5->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac5->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac5->Sep = float(Sep);
		frac5->SplitDis = float(frac4->SplitDis * SplitDisFalloff);
		frac5->Angle = float(Angle);
		frac5->Roll = 39.299999f;
		frac5->Force = float(Force);
		frac5->Cook();
	}
	{
		// Node: frac6
		frac6->SetInput(0, frac5);
		frac6->ForceRamp = ETccRampInterp::Linear;
		frac6->ForceRamp.ResizeRampPoints(3);
		frac6->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac6->ForceRamp.AddRampPoint(0.5648f, 0.0000f);
		frac6->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac6->RadiusShape = ETccRampInterp::Linear;
		frac6->RadiusShape.ResizeRampPoints(2);
		frac6->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac6->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac6->Sep = float(Sep);
		frac6->SplitDis = float(frac5->SplitDis * SplitDisFalloff);
		frac6->Angle = float(Angle);
		frac6->Roll = 27.400000f;
		frac6->Force = float(Force);
		frac6->Cook();
	}
	{
		// Node: frac7
		frac7->SetInput(0, frac6);
		frac7->ForceRamp = ETccRampInterp::Linear;
		frac7->ForceRamp.ResizeRampPoints(3);
		frac7->ForceRamp.AddRampPoint(0.0000f, 0.0000f);
		frac7->ForceRamp.AddRampPoint(0.8658f, 0.0000f);
		frac7->ForceRamp.AddRampPoint(1.0000f, 1.0000f);
		frac7->RadiusShape = ETccRampInterp::Linear;
		frac7->RadiusShape.ResizeRampPoints(2);
		frac7->RadiusShape.AddRampPoint(0.0000f, 1.0000f);
		frac7->RadiusShape.AddRampPoint(1.0000f, 0.7000f);
		frac7->Sep = float(Sep);
		frac7->SplitDis = float(frac6->SplitDis * SplitDisFalloff);
		frac7->Angle = float(Angle);
		frac7->Roll = 28.700001f;
		frac7->Force = float(Force);
		frac7->Cook();
	}
	{
		// Node: tcc_merge1
		tcc_merge1->SetInput(0, frac_base);
		tcc_merge1->SetInput(1, frac1);
		tcc_merge1->SetInput(2, frac2);
		tcc_merge1->SetInput(3, frac3);
		tcc_merge1->SetInput(4, frac4);
		tcc_merge1->SetInput(5, frac5);
		tcc_merge1->SetInput(6, frac6);
		tcc_merge1->SetInput(7, frac7);
		tcc_merge1->Cook();
	}
	{
		// Node: tcc_attrib_delete1
		tcc_attrib_delete1->SetInput(0, tcc_merge1);
		tcc_attrib_delete1->Primdel = TEXT("oddeven");
		tcc_attrib_delete1->Cook();
	}
	SetGeoResult(UTcrTreeBranchFrac::output0, tcc_attrib_delete1->GetGeoResult(0));
}

