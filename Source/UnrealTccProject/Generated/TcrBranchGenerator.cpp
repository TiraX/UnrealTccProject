// Recipe tcr_branch_generator, auto generated by UnrealTcc.

#include "TcrBranchGenerator.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrBranchGenerator::UTcrBranchGenerator() 
{
	MaxInputs = 1;
	tcc_blast_by_feature1 = UTccNode::CreateNodeWithDefine<UTccBlastByFeature>(this, TEXT("tcc_blast_by_feature1"));
	tcc_line1 = UTccNode::CreateNodeWithDefine<UTccLine>(this, TEXT("tcc_line1"));
	need_bend1 = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("need_bend1"));
		tcc_bend1 = UTccNode::CreateNodeWithDefine<UTccBend>(this, TEXT("tcc_bend1"));
	need_bend2 = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("need_bend2"));
		tcc_bend2 = UTccNode::CreateNodeWithDefine<UTccBend>(this, TEXT("tcc_bend2"));
	foreach_branch = UTccNode::CreateNodeWithDefine<UTccForBlock>(this, TEXT("foreach_branch"));
	foreach_branch->InitInputsCount(2);
		add_density_calc_dir = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("add_density_calc_dir"));
		tcc_scatter3 = UTccNode::CreateNodeWithDefine<UTccScatter>(this, TEXT("tcc_scatter3"));
		delete_density = UTccNode::CreateNodeWithDefine<UTccAttribDelete>(this, TEXT("delete_density"));
		tcc_sort1 = UTccNode::CreateNodeWithDefine<UTccSort>(this, TEXT("tcc_sort1"));
		min_max_u = UTccNode::CreateNodeWithDefine<UTccAttribPromote>(this, TEXT("min_max_u"));
		calc_rotation1 = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("calc_rotation1"));
		calc_scale = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("calc_scale"));
		tcc_copy_to_point1 = UTccNode::CreateNodeWithDefine<UTccCopyToPoint>(this, TEXT("tcc_copy_to_point1"));
	add_primattrib_level = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("add_primattrib_level"));
	calc_radius = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("calc_radius"));
	enable_noise = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("enable_noise"));
		tcc_resample1 = UTccNode::CreateNodeWithDefine<UTccResample>(this, TEXT("tcc_resample1"));
		curl_noise = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("curl_noise"));
	tcc_merge1 = UTccNode::CreateNodeWithDefine<UTccMerge>(this, TEXT("tcc_merge1"));
	inc_curr_level = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("inc_curr_level"));
	RscaleAlongCurve.ResizeRampPoints(2);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.5000f);
	LscaleAlongCurve.ResizeRampPoints(2);
	LscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	LscaleAlongCurve.AddRampPoint(1.0000f, 1.0000f);
}
void UTcrBranchGenerator::Execute(UTccNode* InNode) 
{
	{
		tcc_blast_by_feature1->SetInput(0, InNode->GetInput(0));
		FTccGeometryPtr Geo0 = tcc_blast_by_feature1->GetInput(0)->GetGeoResult(0);
		UTccBlastByFeature* Define1 = Cast<UTccBlastByFeature>(tcc_blast_by_feature1->GetDefine()); 
		Define1->ByAttrib = 1;
		Define1->Attrib = TEXT("level");
		Define1->Op = UTccBlastByFeature::NotEqual;
		Define1->Value = float(hs_detail(Geo0, "curr_level", 0));
		tcc_blast_by_feature1->Cook();
	}
	{
		UTccLine* Define1 = Cast<UTccLine>(tcc_line1->GetDefine()); 
		Define1->Dir = FVector3f(0.000000f, 0.000000f, 1.000000f);
		Define1->Dist = float(BranchLength);
		Define1->Points = int32(BranchSegs);
		Define1->Docurveuattr = 1;
		tcc_line1->Cook();
	}
	{
		need_bend1->SetInput(0, tcc_line1);
		UTccSwitch* Define1 = Cast<UTccSwitch>(need_bend1->GetDefine()); 
		Define1->Input = int32(Bend1);
		Define1->NumCases = 2;
		need_bend1->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = Define1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					tcc_bend1->SetInput(0, tcc_line1);
					UTccBend* Define2 = Cast<UTccBend>(tcc_bend1->GetDefine()); 
					Define2->Bend = float(Bend1Angle);
					Define2->Origin = FVector3f(0.000000f, 0.000000f, Bend1Offset);
					Define2->Length = float(BranchLength * Bend1Length);
					tcc_bend1->Cook();
				}
				
				SwitchResult = tcc_bend1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		need_bend1->SetValidGeoResult(0, SwitchResult);
	}
	{
		need_bend2->SetInput(0, need_bend1);
		UTccSwitch* Define1 = Cast<UTccSwitch>(need_bend2->GetDefine()); 
		Define1->Input = int32(Bend2);
		Define1->NumCases = 2;
		need_bend2->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = Define1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					tcc_bend2->SetInput(0, need_bend1);
					UTccBend* Define2 = Cast<UTccBend>(tcc_bend2->GetDefine()); 
					Define2->Bend = float(Bend2Angle);
					Define2->Origin = FVector3f(0.000000f, 0.000000f, Bend2Offset);
					Define2->Length = float(BranchLength * Bend2Length);
					tcc_bend2->Cook();
				}
				
				SwitchResult = tcc_bend2->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		need_bend2->SetValidGeoResult(0, SwitchResult);
	}
	{
		foreach_branch->SetInput(0, tcc_blast_by_feature1);
		foreach_branch->SetInput(1, need_bend2);
		UTccForBlock* Define1 = Cast<UTccForBlock>(foreach_branch->GetDefine()); 
		Define1->Itermethod = UTccForBlock::ByPiecesOrPoints;
		Define1->Method = UTccForBlock::MergeEachIteration;
		Define1->Class = UTccForBlock::Primitives;
		foreach_branch->Cook();
		{
			// By Pieces or Points, Merge Each Iteration, Primitives
			const int32 NumPieces = Define1->GetNumPieces();
			for(int32 piece = 0; piece < NumPieces; piece ++)
			{
				const int32 _iteration = piece;
				UTccNode* block_input0 = NewObject<UTccNode>(GetTransientPackage());
				block_input0->SetGeoResult(0, Define1->GetGeometryPiece(piece));
				UTccNode* block_input1 = need_bend2;
				{
					add_density_calc_dir->SetInput(0, block_input0);
					add_density_calc_dir->Cook();
					{
						FTccGeometryPtr Geo0 = add_density_calc_dir->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_density = Geo0->AddPointAttrib("density", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_tangent = Geo0->AddPointAttrib("tangent", FTccAttrib::EAttrType::F3);
						const FVector2f percent = Gpercent;
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _curveu = attr_curveu->GetData<float>()[i];
							float& _density = attr_density->GetData<float>()[i];
							FVector3f& _tangent = attr_tangent->GetData<FVector3f>()[i];
							// calc density
							float f = _curveu;
							_density = (f >= percent.X && f <= percent.Y)? 1.f : 0.f;
							// calc tangent dir
							FVector3f p0, p1;
							if(_ptnum == _numpt - 1)
							{
							    // last point
							  p0 = vex_pointp(Geo0, _ptnum - 1);
							  p1 = vex_pointp(Geo0, _ptnum);
							}
							else if(_ptnum == 0)
							{
							    // first point
							  p0 = vex_pointp(Geo0, _ptnum);
							  p1 = vex_pointp(Geo0, _ptnum + 1);
							}
							else
							{
							    // other points
							  p0 = vex_pointp(Geo0, _ptnum - 1);
							  p1 = vex_pointp(Geo0, _ptnum + 1);
							}
							FVector3f yaw_axis = vex_normalize(p1 - p0);
							_tangent = yaw_axis;
						}
					}
				}
				
				{
					tcc_scatter3->SetInput(0, add_density_calc_dir);
					UTccScatter* Define2 = Cast<UTccScatter>(tcc_scatter3->GetDefine()); 
					Define2->Usedensityattrib = 1;
					Define2->Npts = int32(Npts);
					Define2->ScatterSeed = int32(BranchSeed);
					tcc_scatter3->Cook();
				}
				
				{
					delete_density->SetInput(0, tcc_scatter3);
					UTccAttribDelete* Define2 = Cast<UTccAttribDelete>(delete_density->GetDefine()); 
					Define2->Ptdel = TEXT("density");
					delete_density->Cook();
				}
				
				{
					tcc_sort1->SetInput(0, delete_density);
					UTccSort* Define2 = Cast<UTccSort>(tcc_sort1->GetDefine()); 
					Define2->Ptsort = UTccSort::ByAttribute;
					Define2->Pointattrib = TEXT("curveu");
					tcc_sort1->Cook();
				}
				
				{
					min_max_u->SetInput(0, tcc_sort1);
					UTccAttribPromote* Define2 = Cast<UTccAttribPromote>(min_max_u->GetDefine()); 
					Define2->Inname = TEXT("curveu");
					Define2->Outclass = UTccAttribPromote::DetailOnlyOnce;
					Define2->DoMax = 1;
					Define2->DoMin = 1;
					min_max_u->Cook();
				}
				
				{
					calc_rotation1->SetInput(0, min_max_u);
					calc_rotation1->SetInput(1, nullptr);
					calc_rotation1->Cook();
					{
						FTccGeometryPtr Geo0 = calc_rotation1->GetGeoResult(0);
						FTccAttribPtr attr_tangent = Geo0->AddPointAttrib("tangent", FTccAttrib::EAttrType::F3);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_orient = Geo0->AddPointAttrib("orient", FTccAttrib::EAttrType::F4);
						const float angle_step = vex_radians(Yaw);
						const FVector2f pitch_r = vex_radians(PitchR);
						const int32 gseed = BranchSeed;
						const int32 iter = _iteration;
						const int32 pattern = Pattern;
						const float yaw_rand = vex_radians(YawRand);
						const float yaw_range = vex_radians(YawRange);
						const float angle_offset = vex_radians(AngleOffset);
						const float num_pt_inv = 1.0f / vex_npoints(Geo0);
						const float max_u = vex_detail(Geo0, "max_curveu");
						const float min_u = vex_detail(Geo0, "min_curveu");
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _tangent = attr_tangent->GetData<FVector3f>()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector4f& _orient = attr_orient->GetData<FVector4f>()[i];
							// calc yaw by pattern
							float yaw = 0;
							if(pattern == 0)
							{
							  yaw = angle_step * _ptnum + angle_offset;
							    // angle step
							  float yaw_r = vex_fit01(vex_rand(gseed * iter + _ptnum + 42),  - yaw_rand, yaw_rand);
							  yaw += yaw_r;
							}
							else
							{
							    // angle range
							  float yaw_step = yaw_range * 2 * num_pt_inv * 2;
							  yaw = yaw_step * _ptnum + angle_offset;
							  if(yaw_range > 0)
							  yaw = vex_fmod(yaw, yaw_range * 2);
							  yaw += angle_step - yaw_range;
							}
							FVector3f yaw_axis = _tangent;
							// calc rotated normal
							FVector3f n = vex_set(0, 1, 0);
							// if n and axis locate in same direction, change n to axis-z
							if(abs(vex_dot(n, yaw_axis))> 0.99f)n = vex_set(1, 0, 0);
							n = vex_cross(n, yaw_axis);
							n = vex_cross(yaw_axis, n);
							FVector4f q = vex_quaternion(yaw, yaw_axis);
							n = vex_qrotate(q, n);
							//@N = n;
							//f@L = length(@N);
							FVector3f pitch_axis = vex_normalize(vex_cross(n, yaw_axis));
							float pitch = vex_fit(_curveu, min_u, max_u, pitch_r.X, pitch_r.Y);
							FVector4f q1 = vex_quaternion(pitch, pitch_axis);
							n = vex_normalize(vex_qrotate(q1, n));
							FMatrix44f m3 = vex_maketransform(n, yaw_axis);
							_orient = vex_quaternion(m3);
						}
					}
				}
				
				{
					calc_scale->SetInput(0, calc_rotation1);
					calc_scale->Cook();
					{
						FTccGeometryPtr Geo0 = calc_scale->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						FTccAttribPtr attr_pscale = Geo0->AddPointAttrib("pscale", FTccAttrib::EAttrType::F);
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							float& _curveu = attr_curveu->GetData<float>()[i];
							float& _pscale = attr_pscale->GetData<float>()[i];
							float p = _curveu;
							_pscale = LscaleAlongCurve.Lookup(p);
						}
					}
				}
				
				{
					tcc_copy_to_point1->SetInput(0, block_input1);
					tcc_copy_to_point1->SetInput(1, calc_scale);
					UTccCopyToPoint* Define2 = Cast<UTccCopyToPoint>(tcc_copy_to_point1->GetDefine()); 
					Define2->AttribToPoints = TEXT("radius");
					tcc_copy_to_point1->Cook();
				}
				
				Define1->SetPieceResult(piece, tcc_copy_to_point1->GetGeoResult(0));
			}
			Define1->MergeResult(foreach_branch);
		}
	}
	{
		add_primattrib_level->SetInput(0, foreach_branch);
		add_primattrib_level->SetInput(1, InNode->GetInput(0));
		add_primattrib_level->Cook();
		{
			FTccGeometryPtr Geo0 = add_primattrib_level->GetGeoResult(0);
			FTccGeometryPtr Geo1 = InNode->GetInput(0)->GetGeoResult(0);
			FTccAttribPtr attr_level = Geo0->AddPrimAttrib("level", FTccAttrib::EAttrType::I);
			const int32 _numprim = Geo0->GetPrimsCount();
			for(int32 i = 0; i < _numprim; i++)
			{
				const int32 _primnum = i;
				int32& _level = attr_level->GetData<int32>()[i];
				int32 curr_level = vex_detaili(Geo1, "curr_level");
				_level = curr_level + 1;
			}
		}
	}
	{
		calc_radius->SetInput(0, add_primattrib_level);
		calc_radius->Cook();
		{
			FTccGeometryPtr Geo0 = calc_radius->GetGeoResult(0);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", FTccAttrib::EAttrType::F);
			const float radius_scale = RadiusScale;
			const int32 _numpt = Geo0->GetPointsCount();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _curveu = attr_curveu->GetData<float>()[i];
				float& _radius = attr_radius->GetData<float>()[i];
				float p = _curveu;
				float base_r = _radius;
				_radius = RscaleAlongCurve.Lookup(p) * base_r * radius_scale;
			}
		}
	}
	{
		enable_noise->SetInput(0, calc_radius);
		UTccSwitch* Define1 = Cast<UTccSwitch>(enable_noise->GetDefine()); 
		Define1->Input = int32(EnableNoise);
		Define1->NumCases = 2;
		enable_noise->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = Define1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					tcc_resample1->SetInput(0, calc_radius);
					UTccResample* Define2 = Cast<UTccResample>(tcc_resample1->GetDefine()); 
					Define2->Dolength = 0;
					Define2->Dosegs = 1;
					Define2->Segs = int32(Segs);
					tcc_resample1->Cook();
				}
				
				{
					curl_noise->SetInput(0, tcc_resample1);
					curl_noise->Cook();
					{
						FTccGeometryPtr Geo0 = curl_noise->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						const float freq = Freq;
						const float amp = Amp;
						const int32 seed = BranchSeed;
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector3f pos = _P * freq + float(seed * 3241);
							FVector3f c = vex_curlnoise2d(pos) * amp;
							_P += c * _curveu;
						}
					}
				}
				
				SwitchResult = curl_noise->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_noise->SetValidGeoResult(0, SwitchResult);
	}
	{
		tcc_merge1->SetInput(0, InNode->GetInput(0));
		tcc_merge1->SetInput(1, enable_noise);
		tcc_merge1->Cook();
	}
	{
		inc_curr_level->SetInput(0, tcc_merge1);
		inc_curr_level->Cook();
		{
			FTccGeometryPtr Geo0 = inc_curr_level->GetGeoResult(0);
			FTccAttribPtr attr_curr_level = Geo0->AddDetailAttrib("curr_level", FTccAttrib::EAttrType::I);
			int32& _curr_level = attr_curr_level->GetData<int32>()[0];
			_curr_level += 1;
		}
	}
	InNode->SetGeoResult(output0, inc_curr_level->GetGeoResult(0));
}

