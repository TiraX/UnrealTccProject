// Recipe tcr_trunk_generator, auto generated by UnrealTcc.

#include "TcrTrunkGenerator.h"
#include "Generated/TccTemplates.h"
#include "TccForBlock.h"
#include "TccSwitch.h"
#include "TccAttribute.h"
#include "TccGeometry.h"
#include "Vex.h"
#include "HScript.h"

 UTcrTrunkGenerator::UTcrTrunkGenerator() 
{
	MaxInputs = 0;
	tcc_line1 = UTccNode::CreateNodeWithDefine<UTccLine>(this, TEXT("tcc_line1"));
	enable_noise = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("enable_noise"));
		curl_noise = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("curl_noise"));
	calc_radius = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("calc_radius"));
	add_attrib_level = UTccNode::CreateNodeWithDefine<UTccVex>(this, TEXT("add_attrib_level"));
	enable_bend = UTccNode::CreateNodeWithDefine<UTccSwitch>(this, TEXT("enable_bend"));
		tcc_bend1 = UTccNode::CreateNodeWithDefine<UTccBend>(this, TEXT("tcc_bend1"));
		tcc_transform1 = UTccNode::CreateNodeWithDefine<UTccTransform>(this, TEXT("tcc_transform1"));
	RscaleAlongCurve.ResizeRampPoints(4);
	RscaleAlongCurve.AddRampPoint(0.0000f, 1.0000f);
	RscaleAlongCurve.AddRampPoint(0.0485f, 0.6875f);
	RscaleAlongCurve.AddRampPoint(0.5756f, 0.6250f);
	RscaleAlongCurve.AddRampPoint(1.0000f, 0.6042f);
}
void UTcrTrunkGenerator::Execute(UTccNode* InNode) 
{
	{
		UTccLine* Define1 = Cast<UTccLine>(tcc_line1->GetDefine()); 
		Define1->Dist = float(Length);
		Define1->Points = int32(Segs);
		Define1->Docurveuattr = 1;
		tcc_line1->Cook();
	}
	{
		enable_noise->SetInput(0, tcc_line1);
		UTccSwitch* Define1 = Cast<UTccSwitch>(enable_noise->GetDefine()); 
		Define1->Input = int32(Amp > 0);
		Define1->NumCases = 2;
		enable_noise->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = Define1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					curl_noise->SetInput(0, tcc_line1);
					curl_noise->Cook();
					{
						FTccGeometryPtr Geo0 = curl_noise->GetGeoResult(0);
						FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
						const float freq = Freq;
						const float amp = Amp;
						const int32 seed = Nseed;
						const int32 _numpt = Geo0->GetPointsCount();
						for(int32 i = 0; i < _numpt; i++)
						{
							const int32 _ptnum = i;
							FVector3f& _P = Geo0->GetPositions()[i];
							float& _curveu = attr_curveu->GetData<float>()[i];
							FVector3f pos = _P * freq + float(seed * 6251);
							pos = vex_set(pos.X, pos.Y, pos.Z);
							FVector3f c = vex_curlnoise2d(pos) * amp;
							_P += c * _curveu;
						}
					}
				}
				
				SwitchResult = curl_noise->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_noise->SetValidGeoResult(0, SwitchResult);
	}
	{
		calc_radius->SetInput(0, enable_noise);
		calc_radius->Cook();
		{
			FTccGeometryPtr Geo0 = calc_radius->GetGeoResult(0);
			FTccAttribPtr attr_curveu = Geo0->AddPointAttrib("curveu", FTccAttrib::EAttrType::F);
			FTccAttribPtr attr_radius = Geo0->AddPointAttrib("radius", FTccAttrib::EAttrType::F);
			const int32 _numpt = Geo0->GetPointsCount();
			for(int32 i = 0; i < _numpt; i++)
			{
				const int32 _ptnum = i;
				float& _curveu = attr_curveu->GetData<float>()[i];
				float& _radius = attr_radius->GetData<float>()[i];
				float p = _curveu;
				float base_r = Radius;
				_radius = RscaleAlongCurve.Lookup(p) * base_r;
			}
		}
	}
	{
		add_attrib_level->SetInput(0, calc_radius);
		add_attrib_level->Cook();
		{
			FTccGeometryPtr Geo0 = add_attrib_level->GetGeoResult(0);
			vex_setprimattrib(Geo0, "level", 0, 0);
			vex_setdetailattrib(Geo0, "curr_level", 0);
		}
	}
	{
		enable_bend->SetInput(0, add_attrib_level);
		UTccSwitch* Define1 = Cast<UTccSwitch>(enable_bend->GetDefine()); 
		Define1->Input = int32(EnableBend);
		Define1->NumCases = 2;
		enable_bend->Cook();
		FTccGeometryPtr SwitchResult = nullptr;
		const int32 Selection = Define1->Input;
		switch (Selection)
		{
			case 0:
			{
				
				
				SwitchResult = nullptr;
			}
			break;
			case 1:
			{
				{
					tcc_bend1->SetInput(0, add_attrib_level);
					UTccBend* Define2 = Cast<UTccBend>(tcc_bend1->GetDefine()); 
					Define2->Bend = float(Bend);
					Define2->Dir = FVector3f(0.000000f, 1.000000f, 0.000000f);
					Define2->Length = float(Length);
					tcc_bend1->Cook();
				}
				
				{
					tcc_transform1->SetInput(0, tcc_bend1);
					UTccTransform* Define2 = Cast<UTccTransform>(tcc_transform1->GetDefine()); 
					Define2->R = FVector3f(0.000000f, 90.000000f, 0.000000f);
					tcc_transform1->Cook();
				}
				
				SwitchResult = tcc_transform1->GetGeoResult(0);
			}
			break;
			default:
			{
				checkNoEntry();
			}
			break;
		}
		enable_bend->SetValidGeoResult(0, SwitchResult);
	}
	InNode->SetGeoResult(output0, enable_bend->GetGeoResult(0));
}

